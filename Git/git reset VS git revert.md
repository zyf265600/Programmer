# `git reset` VS `git revert` 

> **reset = 改历史**
> **revert = 加一条反向历史**

------

# 一、`git reset` 是什么

## 本质

**移动分支指针（rewrite history）**

它会把当前 branch 往回拖，
好像“那几个 commit 从来没存在过”。

------

## 示例

原来：

```
A — B — C — D   (main, HEAD)
```

执行：

```bash
git reset --hard B
```

变成：

```
A — B   (main, HEAD)
C D 失去分支指针
```

历史被“剪掉”。

------

## 三种模式

| 模式              | commit | 暂存区 | 工作区 |
| ----------------- | ------ | ------ | ------ |
| `--soft`          | 回退   | 保留   | 保留   |
| `--mixed`（默认） | 回退   | 清空   | 保留   |
| `--hard`          | 回退   | 清空   | 清空   |

------

## 特点

- 改历史
- 适合 **本地操作**
- 不适合已 push 的公共分支
- 可以“撤销错误 commit”

------

# 二、`git revert` 是什么

## 本质

**生成一个“反向 commit”（preserve history）**

不是删 commit，而是再加一个新的 commit，
把之前的修改“抵消”。

------

## 示例

原来：

```
A — B — C — D   (main)
```

执行：

```bash
git revert D
```

变成：

```
A — B — C — D — E
              ↑
          E = 反向修改
```

历史完整保留，只是多了一步“撤销”。

------

## 特点

- 不改历史
- 安全
- 适合 **团队 / 已 push 分支**
- 所有人历史一致

------

# 三、核心区别

| 维度              | reset    | revert   |
| ----------------- | -------- | -------- |
| 是否改历史        | 会       | 不会     |
| 是否生成新 commit | 不会     | 会       |
| 适合场景          | 本地修错 | 团队回滚 |
| 危险性            | 高       | 低       |
| 分支指针          | 会移动   | 不动     |

------

# 四、什么时候用哪个

## 用 `reset`

- 还没 push
- 自己一个人开发
- 想把 commit 彻底删掉
- 重写历史

------

## 用 `revert`

- 已经 push
- 团队协作
- 想“安全撤销”
- 不能破坏历史

------

# 五、一句话记忆

- **reset = 时间倒流**
- **revert = 写一条“撤销说明”**