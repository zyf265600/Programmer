#define _CRT_SECURE_NO_WARNINGS 1

// 今天在听课的时候听到一个老师讲 平均数求法，一时之间我竟无从下手，其实这个问题很早之前我们老师就说过了。
// 虽然这种题确实是一种考验计算机专业的人的专业度的问题，但是大多老师讲完之后恐怕根本也不会去给你布置
// 练习来强化你的记忆，所以你可能会很快忘记这种特殊的解法（也许是我太卑微了，大家都过目不忘？？）。
 //所以，大多时候，讲到这个的老师无非是为了炫技，让你觉得他很专业。

// 但是我忘记了是真的，我没能想出来也是真的，我真菜啊，所以，我决定动手写一下

#include<stdio.h>

int main(void) {

	int a = 10;
	int b = 11;
	double aver;
	int Aver;

	// 方法1：直接求和除以2  这种方法的问题是：如果 a + b 会超过 int 最大能表示的范围，那结果就不是你想要的了

	
	
	// 方法2：

	// 确定两个的大小
	int max = a > b ? a : b;
	int min = a < b ? a : b;

	// 平均值等于：大 - 后面这一坨 或者 小 + 后面这一坨
	aver = max - (max - min) / 2.0;
	
	// 比较僵硬的是，整数的平均值要用浮点数来表示，不然可能会丧失精度
	printf("%.2f\n", aver);



	// 方法3：这个方法可以说就是炫技的地方所在了，但是位运算确实效率是比较高的。
	
	Aver = (a & b) + ((a ^ b) >> 1);
	printf("%d\n", Aver);
	
	// a & b 得到的是 a，b 相同二进制位所表示的数
	// 比如 2 和 2 相同，那他们的平均值就是 2
	// a ^ b 表示 a 异或 b，得到的是 a，b 不同二进制位的和表示的数，除以 2，就是这部分两数的平均值。
	// 其实这个思想挺像 方法2 的思想，就将数分为两部分，依靠 2 进制的性质进行计算。
	// 位运算会向下取整，如果要求平均值有小数部分，那这个方法也就僵硬了	
	// 参考博客：https://blog.csdn.net/weixin_43214609/article/details/83547313?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

	return 0;
}

