### ğŸ“º è§†é¢‘é¢˜è§£

![236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ.mp4](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/6258a388-b9c6-486c-9d92-c09571d373a9)

### ğŸ“– æ–‡å­—é¢˜è§£

#### æ–¹æ³•ä¸€ï¼šé€’å½’

**æ€è·¯å’Œç®—æ³•**

æˆ‘ä»¬é€’å½’éå†æ•´æ£µäºŒå‰æ ‘ï¼Œå®šä¹‰ $f_x$ è¡¨ç¤º $x$ èŠ‚ç‚¹çš„å­æ ‘ä¸­æ˜¯å¦åŒ…å« $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ï¼Œå¦‚æœåŒ…å«ä¸º `true`ï¼Œå¦åˆ™ä¸º `false`ã€‚é‚£ä¹ˆç¬¦åˆæ¡ä»¶çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ $x$ ä¸€å®šæ»¡è¶³å¦‚ä¸‹æ¡ä»¶ï¼š

$$
(f_{\text{lson}}\ \&\&\ f_{\text{rson}})\ ||\ ((x\ =\ p\ ||\ x\ =\ q)\ \&\&\ (f_{\text{lson}}\ ||\ f_{\text{rson}}))
$$

å…¶ä¸­ $\text{lson}$ å’Œ $\text{rson}$ åˆ†åˆ«ä»£è¡¨ $x$ èŠ‚ç‚¹çš„å·¦å­©å­å’Œå³å­©å­ã€‚åˆçœ‹å¯èƒ½ä¼šæ„Ÿè§‰æ¡ä»¶åˆ¤æ–­æœ‰ç‚¹å¤æ‚ï¼Œæˆ‘ä»¬æ¥ä¸€æ¡æ¡çœ‹ï¼Œ$f_{\text{lson}}\ \&\&\ f_{\text{rson}}$ è¯´æ˜å·¦å­æ ‘å’Œå³å­æ ‘å‡åŒ…å« $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ï¼Œå¦‚æœå·¦å­æ ‘åŒ…å«çš„æ˜¯ $p$ èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå³å­æ ‘åªèƒ½åŒ…å« $q$ èŠ‚ç‚¹ï¼Œåä¹‹äº¦ç„¶ï¼Œå› ä¸º $p$ èŠ‚ç‚¹å’Œ $q$ èŠ‚ç‚¹éƒ½æ˜¯ä¸åŒä¸”å”¯ä¸€çš„èŠ‚ç‚¹ï¼Œå› æ­¤å¦‚æœæ»¡è¶³è¿™ä¸ªåˆ¤æ–­æ¡ä»¶å³å¯è¯´æ˜ $x$ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚å†æ¥çœ‹ç¬¬äºŒæ¡åˆ¤æ–­æ¡ä»¶ï¼Œè¿™ä¸ªåˆ¤æ–­æ¡ä»¶å³æ˜¯è€ƒè™‘äº† $x$ æ°å¥½æ˜¯ $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ä¸”å®ƒçš„å·¦å­æ ‘æˆ–å³å­æ ‘æœ‰ä¸€ä¸ªåŒ…å«äº†å¦ä¸€ä¸ªèŠ‚ç‚¹çš„æƒ…å†µï¼Œå› æ­¤å¦‚æœæ»¡è¶³è¿™ä¸ªåˆ¤æ–­æ¡ä»¶äº¦å¯è¯´æ˜ $x$ å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ä½ å¯èƒ½ä¼šç–‘æƒ‘è¿™æ ·æ‰¾å‡ºæ¥çš„å…¬å…±ç¥–å…ˆæ·±åº¦æ˜¯å¦æ˜¯æœ€å¤§çš„ã€‚å…¶å®æ˜¯æœ€å¤§çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯è‡ªåº•å‘ä¸Šä»å¶å­èŠ‚ç‚¹å¼€å§‹æ›´æ–°çš„ï¼Œæ‰€ä»¥åœ¨æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„å…¬å…±ç¥–å…ˆä¸­ä¸€å®šæ˜¯æ·±åº¦æœ€å¤§çš„ç¥–å…ˆå…ˆè¢«è®¿é—®åˆ°ï¼Œä¸”ç”±äº $f_x$ æœ¬èº«çš„å®šä¹‰å¾ˆå·§å¦™ï¼Œåœ¨æ‰¾åˆ°æœ€è¿‘å…¬å…±ç¥–å…ˆ $x$ ä»¥åï¼Œ$f_x$ æŒ‰å®šä¹‰è¢«è®¾ç½®ä¸º `true` ï¼Œå³å‡å®šäº†è¿™ä¸ªå­æ ‘ä¸­åªæœ‰ä¸€ä¸ª $p$ èŠ‚ç‚¹æˆ– $q$ èŠ‚ç‚¹ï¼Œå› æ­¤å…¶ä»–å…¬å…±ç¥–å…ˆä¸ä¼šå†è¢«åˆ¤æ–­ä¸ºç¬¦åˆæ¡ä»¶ã€‚

ä¸‹å›¾å±•ç¤ºäº†ä¸€ä¸ªç¤ºä¾‹ï¼Œæœç´¢æ ‘ä¸­ä¸¤ä¸ªèŠ‚ç‚¹ `9` å’Œ `11` çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

<![fig1](https://assets.leetcode-cn.com/solution-static/236/1.PNG),![fig2](https://assets.leetcode-cn.com/solution-static/236/2.PNG),![fig3](https://assets.leetcode-cn.com/solution-static/236/3.PNG),![fig4](https://assets.leetcode-cn.com/solution-static/236/4.PNG),![fig5](https://assets.leetcode-cn.com/solution-static/236/5.PNG),![fig6](https://assets.leetcode-cn.com/solution-static/236/6.PNG),![fig7](https://assets.leetcode-cn.com/solution-static/236/7.PNG),![fig8](https://assets.leetcode-cn.com/solution-static/236/8.PNG),![fig9](https://assets.leetcode-cn.com/solution-static/236/9.PNG),![fig10](https://assets.leetcode-cn.com/solution-static/236/10.PNG),![fig11](https://assets.leetcode-cn.com/solution-static/236/11.PNG)>

* [sol1-C++]

```C++
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return false;
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return ans;
    }
};
```

* [sol1-JavaScript]

```JavaScript
var lowestCommonAncestor = function(root, p, q) {
    let ans;
    const dfs = (root, p, q) => {
        if (root === null) return false;
        const lson = dfs(root.left, p, q);
        const rson = dfs(root.right, p, q);
        if ((lson && rson) || ((root.val === p.val || root.val === q.val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root.val === p.val || root.val === q.val);
    }
    dfs(root, p, q);
    return ans;
};
```

* [sol1-Java]

```Java
class Solution {

    private TreeNode ans;

    public Solution() {
        this.ans = null;
    }

    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return false;
        boolean lson = dfs(root.left, p, q);
        boolean rson = dfs(root.right, p, q);
        if ((lson && rson) || ((root.val == p.val || root.val == q.val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root.val == p.val || root.val == q.val);
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        this.dfs(root, p, q);
        return this.ans;
    }
}
```

* [sol1-Golang]

```golang
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val == p.Val || root.Val == q.Val {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil && right != nil {
        return root
    }
    if left == nil {
        return right
    }
    return left
}
```

**å¤æ‚åº¦åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚äºŒå‰æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æœ‰ä¸”åªä¼šè¢«è®¿é—®ä¸€æ¬¡ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º $O(N)$ã€‚

* ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚é€’å½’è°ƒç”¨çš„æ ˆæ·±åº¦å–å†³äºäºŒå‰æ ‘çš„é«˜åº¦ï¼ŒäºŒå‰æ ‘æœ€åæƒ…å†µä¸‹ä¸ºä¸€æ¡é“¾ï¼Œæ­¤æ—¶é«˜åº¦ä¸º $N$ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ã€‚

#### æ–¹æ³•äºŒï¼šå­˜å‚¨çˆ¶èŠ‚ç‚¹

**æ€è·¯**

æˆ‘ä»¬å¯ä»¥ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¿¡æ¯ä» `p` ç»“ç‚¹å¼€å§‹ä¸æ–­å¾€ä¸Šè·³ï¼Œå¹¶è®°å½•å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œå†ä» `q` èŠ‚ç‚¹å¼€å§‹ä¸æ–­å¾€ä¸Šè·³ï¼Œå¦‚æœç¢°åˆ°å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

**ç®—æ³•**

1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†æ•´æ£µäºŒå‰æ ‘ï¼Œç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æŒ‡é’ˆã€‚
2. ä» `p` èŠ‚ç‚¹å¼€å§‹ä¸æ–­å¾€å®ƒçš„ç¥–å…ˆç§»åŠ¨ï¼Œå¹¶ç”¨æ•°æ®ç»“æ„è®°å½•å·²ç»è®¿é—®è¿‡çš„ç¥–å…ˆèŠ‚ç‚¹ã€‚
3. åŒæ ·ï¼Œæˆ‘ä»¬å†ä» `q` èŠ‚ç‚¹å¼€å§‹ä¸æ–­å¾€å®ƒçš„ç¥–å…ˆç§»åŠ¨ï¼Œå¦‚æœæœ‰ç¥–å…ˆå·²ç»è¢«è®¿é—®è¿‡ï¼Œå³æ„å‘³ç€è¿™æ˜¯ `p` å’Œ `q` çš„æ·±åº¦æœ€æ·±çš„å…¬å…±ç¥–å…ˆï¼Œå³ LCA èŠ‚ç‚¹ã€‚

* [sol2-C++]

```C++
class Solution {
public:
    unordered_map<int, TreeNode*> fa;
    unordered_map<int, bool> vis;
    void dfs(TreeNode* root){
        if (root->left != nullptr) {
            fa[root->left->val] = root;
            dfs(root->left);
        }
        if (root->right != nullptr) {
            fa[root->right->val] = root;
            dfs(root->right);
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        fa[root->val] = nullptr;
        dfs(root);
        while (p != nullptr) {
            vis[p->val] = true;
            p = fa[p->val];
        }
        while (q != nullptr) {
            if (vis[q->val]) return q;
            q = fa[q->val];
        }
        return nullptr;
    }
};
```

* [sol2-Java]

```Java
class Solution {
    Map<Integer, TreeNode> parent = new HashMap<Integer, TreeNode>();
    Set<Integer> visited = new HashSet<Integer>();

    public void dfs(TreeNode root) {
        if (root.left != null) {
            parent.put(root.left.val, root);
            dfs(root.left);
        }
        if (root.right != null) {
            parent.put(root.right.val, root);
            dfs(root.right);
        }
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root);
        while (p != null) {
            visited.add(p.val);
            p = parent.get(p.val);
        }
        while (q != null) {
            if (visited.contains(q.val)) {
                return q;
            }
            q = parent.get(q.val);
        }
        return null;
    }
}
```

* [sol2-Golang]

```golang
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    parent := map[int]*TreeNode{}
    visited := map[int]bool{}

    var dfs func(*TreeNode)
    dfs = func(r *TreeNode) {
        if r == nil {
            return
        }
        if r.Left != nil {
            parent[r.Left.Val] = r
            dfs(r.Left)
        }
        if r.Right != nil {
            parent[r.Right.Val] = r
            dfs(r.Right)
        }
    }
    dfs(root)

    for p != nil {
        visited[p.Val] = true
        p = parent[p.Val]
    }
    for q != nil {
        if visited[q.Val] {
            return q
        }
        q = parent[q.Val]
    }

    return nil
}
```

**å¤æ‚åº¦åˆ†æ**

* æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚äºŒå‰æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æœ‰ä¸”åªä¼šè¢«è®¿é—®ä¸€æ¬¡ï¼Œä» `p` å’Œ `q` èŠ‚ç‚¹å¾€ä¸Šè·³ç»è¿‡çš„ç¥–å…ˆèŠ‚ç‚¹ä¸ªæ•°ä¸ä¼šè¶…è¿‡ $N$ï¼Œå› æ­¤æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N)$ã€‚

* ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ ï¼Œå…¶ä¸­ $N$ æ˜¯äºŒå‰æ ‘çš„èŠ‚ç‚¹æ•°ã€‚é€’å½’è°ƒç”¨çš„æ ˆæ·±åº¦å–å†³äºäºŒå‰æ ‘çš„é«˜åº¦ï¼ŒäºŒå‰æ ‘æœ€åæƒ…å†µä¸‹ä¸ºä¸€æ¡é“¾ï¼Œæ­¤æ—¶é«˜åº¦ä¸º $N$ï¼Œå› æ­¤ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ï¼Œå“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¹Ÿéœ€è¦ $O(N)$ çš„ç©ºé—´å¤æ‚åº¦ï¼Œå› æ­¤æœ€åæ€»çš„ç©ºé—´å¤æ‚åº¦ä¸º $O(N)$ã€‚

