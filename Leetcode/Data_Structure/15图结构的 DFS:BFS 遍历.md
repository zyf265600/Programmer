# å›¾ç»“æ„çš„ DFS/BFS éå†

å‰ç½®çŸ¥è¯†

é˜…è¯»æœ¬æ–‡å‰ï¼Œä½ éœ€è¦å…ˆå­¦ä¹ ï¼š

- å›¾ç»“æ„åŸºç¡€åŠé€šç”¨ä»£ç å®ç°
- å¤šå‰æ ‘çš„é€’å½’/å±‚åºéå†

ä¸€å¥è¯æ€»ç»“

å›¾çš„éå†å°±æ˜¯ å¤šå‰æ ‘éå† çš„å»¶ä¼¸ï¼Œä¸»è¦éå†æ–¹å¼è¿˜æ˜¯æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ã€‚

å”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œæ ‘ç»“æ„ä¸­ä¸å­˜åœ¨ç¯ï¼Œè€Œå›¾ç»“æ„ä¸­å¯èƒ½å­˜åœ¨ç¯ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ ‡è®°éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé¿å…éå†å‡½æ•°åœ¨ç¯ä¸­æ­»å¾ªç¯ã€‚

éå†å›¾çš„ã€ŒèŠ‚ç‚¹ã€å’Œã€Œè·¯å¾„ã€ç•¥æœ‰ä¸åŒï¼Œéå†ã€ŒèŠ‚ç‚¹ã€æ—¶ï¼Œéœ€è¦ `visited` æ•°ç»„åœ¨å‰åºä½ç½®æ ‡è®°èŠ‚ç‚¹ï¼›éå†å›¾çš„æ‰€æœ‰ã€Œè·¯å¾„ã€æ—¶ï¼Œéœ€è¦ `onPath` æ•°ç»„åœ¨å‰åºä½ç½®æ ‡è®°èŠ‚ç‚¹ï¼Œåœ¨ååºä½ç½®æ’¤é”€æ ‡è®°ã€‚

å¯è§†åŒ–é¢æ¿ æ”¯æŒåˆ›å»ºå›¾ç»“æ„ï¼ŒåŒæ—¶æ”¯æŒå¯è§†åŒ– DFS/BFS éå†çš„è·¯å¾„ã€‚**ä½ å¯ä»¥ç›´è§‚åœ°çœ‹åˆ°ï¼Œå›¾ç»“æ„çœ‹èµ·æ¥è™½ç„¶æ¯”æ ‘ç»“æ„å¤æ‚ï¼Œä½†å›¾çš„éå†æœ¬è´¨ä¸Šè¿˜æ˜¯æ ‘çš„éå†**ã€‚

å…ˆçœ‹ DFS ç®—æ³•ï¼Œä½ å¯ä»¥æ‰“å¼€ä¸‹é¢çš„å¯è§†åŒ–é¢æ¿ï¼Œå¤šæ¬¡ç‚¹å‡» `console.log` è¿™è¡Œä»£ç ï¼Œå³å¯çœ‹åˆ° DFS éå†å›¾çš„è¿‡ç¨‹ï¼Œæ³¨æ„ `traverse` å‡½æ•°çš„é€’å½’è¿‡ç¨‹

ä¸‹é¢æˆ‘ç»“åˆä»£ç å’Œå¯è§†åŒ–é¢æ¿ï¼Œå…·ä½“è§£é‡Šä¸Šè¿°æ€»ç»“ã€‚

## æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰

å‰æ–‡ å›¾ç»“æ„åŸºç¡€å’Œé€šç”¨å®ç° ä¸­è¯´äº†ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¸ç”¨ `Vertex` è¿™æ ·çš„ç±»æ¥å­˜å‚¨å›¾ï¼Œä½†æ˜¯è¿™é‡Œæˆ‘è¿˜æ˜¯å…ˆç”¨ä¸€ä¸‹è¿™ä¸ªç±»ï¼Œä»¥ä¾¿å¤§å®¶æŠŠå›¾çš„éå†å’Œå¤šå‰æ ‘çš„éå†åšå¯¹æ¯”ã€‚åé¢æˆ‘ä¼šç»™å‡ºåŸºäºé‚»æ¥è¡¨/é‚»æ¥çŸ©é˜µçš„éå†ä»£ç ã€‚

### éå†æ‰€æœ‰èŠ‚ç‚¹ï¼ˆ`visited` æ•°ç»„ï¼‰

å¯¹æ¯”å¤šå‰æ ‘çš„éå†æ¡†æ¶çœ‹å›¾çš„éå†æ¡†æ¶å§ï¼š

```python
# å¤šå‰æ ‘èŠ‚ç‚¹
class Node:
    def __init__(self, val=0, children=None):
        self.val = val
        self.children = children if children is not None else []

# å¤šå‰æ ‘çš„éå†æ¡†æ¶
def traverse(root):
    # base case
    if root is None:
        return
    # å‰åºä½ç½®
    print(f"visit {root.val}")
    for child in root.children:
        traverse(child)
    # ååºä½ç½®

# å›¾èŠ‚ç‚¹
class Vertex:
    def __init__(self, id=0, neighbors=None):
        self.id = id
        self.neighbors = neighbors if neighbors is not None else []

# å›¾çš„éå†æ¡†æ¶
# éœ€è¦ä¸€ä¸ª visited æ•°ç»„è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹
# é¿å…èµ°å›å¤´è·¯é™·å…¥æ­»å¾ªç¯
def traverse_graph(s, visited):
    # base case
    if s is None:
        return
    if visited.get(s.id, False):
        # é˜²æ­¢æ­»å¾ªç¯
        return
    # å‰åºä½ç½®
    visited[s.id] = True
    print(f"visit {s.id}")
    for neighbor in s.neighbors:
        traverse_graph(neighbor)
    # ååºä½ç½®
```

å¯ä»¥çœ‹åˆ°ï¼Œå›¾çš„éå†æ¯”å¤šå‰æ ‘çš„éå†å¤šäº†ä¸€ä¸ª `visited` æ•°ç»„ï¼Œç”¨æ¥è®°å½•è¢«éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé¿å…é‡åˆ°ç¯æ—¶é™·å…¥æ­»å¾ªç¯ã€‚

ä¸ºä»€ä¹ˆæˆç¯ä¼šå¯¼è‡´æ­»å¾ªç¯

ä¸¾ä¸ªæœ€ç®€å•çš„æˆç¯åœºæ™¯ï¼Œæœ‰ä¸€æ¡ `1 -> 2` çš„è¾¹ï¼ŒåŒæ—¶æœ‰ä¸€æ¡ `2 -> 1` çš„è¾¹ï¼ŒèŠ‚ç‚¹ `1, 2` å°±å½¢æˆäº†ä¸€ä¸ªç¯ï¼š



```python
1 <=> 2
```

å¦‚æœæˆ‘ä»¬ä¸æ ‡è®°éå†è¿‡çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä» `1` å¼€å§‹éå†ï¼Œä¼šèµ°åˆ° `2`ï¼Œå†èµ°åˆ° `1`ï¼Œå†èµ°åˆ° `2`ï¼Œå†èµ°åˆ° `1`ï¼Œå¦‚æ­¤ `1->2->1->2->...` æ— é™é€’å½’å¾ªç¯ä¸‹å»ã€‚

å¦‚æœæœ‰äº† `visited` æ•°ç»„ï¼Œç¬¬ä¸€æ¬¡éå†åˆ° `1` æ—¶ï¼Œä¼šæ ‡è®° `1` ä¸ºå·²è®¿é—®ï¼Œå‡ºç° `1->2->1` è¿™ç§æƒ…å†µæ—¶ï¼Œå‘ç° `1` å·²ç»è¢«è®¿é—®è¿‡ï¼Œå°±ä¼šç›´æ¥è¿”å›ï¼Œä»è€Œç»ˆæ­¢é€’å½’ï¼Œé¿å…äº†æ­»å¾ªç¯ã€‚

æœ‰äº†ä¸Šé¢çš„é“ºå«ï¼Œå°±å¯ä»¥å†™å‡ºåŸºäºé‚»æ¥è¡¨/é‚»æ¥çŸ©é˜µçš„å›¾éå†ä»£ç äº†ã€‚è™½ç„¶é‚»æ¥è¡¨/é‚»æ¥çŸ©é˜µçš„åº•å±‚å­˜å‚¨æ–¹å¼ä¸åŒï¼Œä½†æä¾›äº†ç»Ÿä¸€çš„ APIï¼Œæ‰€ä»¥ç›´æ¥ä½¿ç”¨ å›¾ç»“æ„åŸºç¡€å’Œé€šç”¨å®ç° ä¸­é‚£ä¸ª `Graph` æ¥å£çš„æ–¹æ³•å³å¯ï¼š





```python
# éå†å›¾çš„æ‰€æœ‰èŠ‚ç‚¹
def traverse(graph, s, visited):
    # base case
    if s < 0 or s >= len(graph):
        return
    if visited[s]:
        # é˜²æ­¢æ­»å¾ªç¯
        return
    # å‰åºä½ç½®
    visited[s] = True
    print("visit", s)
    for e in graph.neighbors(s):
        traverse(graph, e.to, visited)
    # ååºä½ç½®
```

ä½ å¯ä»¥æ‰“å¼€ä¸‹é¢çš„å¯è§†åŒ–é¢æ¿ï¼Œå¤šæ¬¡ç‚¹å‡» `console.log` è¿™è¡Œä»£ç ï¼Œå³å¯çœ‹åˆ° DFS éå†å›¾çš„è¿‡ç¨‹ï¼š



ç”±äº `visited` æ•°ç»„çš„å‰ªæä½œç”¨ï¼Œè¿™ä¸ªéå†å‡½æ•°ä¼šéå†ä¸€æ¬¡å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶å°è¯•éå†ä¸€æ¬¡æ‰€æœ‰è¾¹ï¼Œæ‰€ä»¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(E+V)*O*(*E*+*V*)ï¼Œå…¶ä¸­ `E` æ˜¯è¾¹çš„æ€»æ•°ï¼Œ`V` æ˜¯èŠ‚ç‚¹çš„æ€»æ•°ã€‚

æ—¶é—´å¤æ‚åº¦ä¸ºä»€ä¹ˆæ˜¯ O(E+V)*O*(*E*+*V*)ï¼Ÿ

æˆ‘ä»¬ä¹‹å‰è®²è§£ äºŒå‰æ ‘çš„éå† æ—¶è¯´ï¼ŒäºŒå‰æ ‘çš„éå†å‡½æ•°æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)*O*(*N*)ï¼Œå…¶ä¸­ N*N* æ˜¯èŠ‚ç‚¹çš„æ€»æ•°ã€‚

è¿™é‡Œå›¾ç»“æ„æ—¢ç„¶æ˜¯æ ‘ç»“æ„çš„å»¶ä¼¸ï¼Œä¸ºä»€ä¹ˆå›¾çš„éå†å‡½æ•°æ—¶é—´å¤æ‚åº¦æ˜¯ O(E+V)*O*(*E*+*V*)ï¼Œè¦æŠŠè¾¹çš„æ•°é‡ E*E* ä¹Ÿç®—è¿›å»å‘¢ï¼Ÿä¸ºä»€ä¹ˆä¸æ˜¯ O(V)*O*(*V*) å‘¢ï¼Ÿ

è¿™æ˜¯ä¸ªéå¸¸å¥½çš„é—®é¢˜ã€‚ä½ å¯ä»¥èŠ±ä¸Šä¸¤åˆ†é’Ÿæƒ³æƒ³ï¼Œæˆ‘æŠŠç­”æ¡ˆå†™åœ¨ä¸‹é¢ã€‚



### éå†æ‰€æœ‰è·¯å¾„ï¼ˆ`onPath` æ•°ç»„ï¼‰

å¯¹äºæ ‘ç»“æ„ï¼Œéå†æ‰€æœ‰ã€Œè·¯å¾„ã€å’Œéå†æ‰€æœ‰ã€ŒèŠ‚ç‚¹ã€æ˜¯æ²¡ä»€ä¹ˆåŒºåˆ«çš„ã€‚è€Œå¯¹äºå›¾ç»“æ„ï¼Œéå†æ‰€æœ‰ã€Œè·¯å¾„ã€å’Œéå†æ‰€æœ‰ã€ŒèŠ‚ç‚¹ã€ç¨æœ‰ä¸åŒã€‚

å› ä¸ºå¯¹äºæ ‘ç»“æ„æ¥è¯´ï¼Œåªèƒ½ç”±çˆ¶èŠ‚ç‚¹æŒ‡å‘å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä»æ ¹èŠ‚ç‚¹ `root` å‡ºå‘ï¼Œåˆ°ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ `targetNode` çš„è·¯å¾„éƒ½æ˜¯å”¯ä¸€çš„ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘éå†ä¸€éæ ‘ç»“æ„çš„æ‰€æœ‰èŠ‚ç‚¹ä¹‹åï¼Œå¿…ç„¶å¯ä»¥æ‰¾åˆ° `root` åˆ° `targetNode` çš„å”¯ä¸€è·¯å¾„ï¼š

```python
# å¤šå‰æ ‘çš„éå†æ¡†æ¶ï¼Œå¯»æ‰¾ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·¯å¾„
path = []

def traverse(root, targetNode):
    # base case
    if root is None:
        return
    
    # å‰åºä½ç½®
    path.append(root)
    if root.val == targetNode.val:
        print("find path:", path)
    
    for child in root.children:
        traverse(child, targetNode)
    
    # ååºä½ç½®
    path.pop()
```

è€Œå¯¹äºå›¾ç»“æ„æ¥è¯´ï¼Œç”±èµ·ç‚¹ `src` åˆ°ç›®æ ‡èŠ‚ç‚¹ `dest` çš„è·¯å¾„å¯èƒ½ä¸æ­¢ä¸€æ¡ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ª `onPath` æ•°ç»„ï¼Œåœ¨è¿›å…¥èŠ‚ç‚¹æ—¶ï¼ˆå‰åºä½ç½®ï¼‰æ ‡è®°ä¸ºæ­£åœ¨è®¿é—®ï¼Œé€€å‡ºèŠ‚ç‚¹æ—¶ï¼ˆååºä½ç½®ï¼‰æ’¤é”€æ ‡è®°ï¼Œè¿™æ ·æ‰èƒ½éå†å›¾ä¸­çš„æ‰€æœ‰è·¯å¾„ï¼Œä»è€Œæ‰¾åˆ° `src` åˆ° `dest` çš„æ‰€æœ‰è·¯å¾„ï¼š





```python
# ä¸‹é¢çš„ç®—æ³•ä»£ç å¯ä»¥éå†å›¾çš„æ‰€æœ‰è·¯å¾„ï¼Œå¯»æ‰¾ä» src åˆ° dest çš„æ‰€æœ‰è·¯å¾„

# onPath å’Œ path è®°å½•å½“å‰é€’å½’è·¯å¾„ä¸Šçš„èŠ‚ç‚¹
on_path = [False] * len(graph)
path = []

def traverse(graph, src, dest):
    # base case
    if src < 0 or src >= len(graph):
        return
    if on_path[src]:
        # é˜²æ­¢æ­»å¾ªç¯ï¼ˆæˆç¯ï¼‰
        return
    # å‰åºä½ç½®
    on_path[src] = True
    path.append(src)
    if src == dest:
        print(f"find path: {path}")
    for e in graph.neighbors(src):
        traverse(graph, e.to, dest)
    # ååºä½ç½®
    path.pop()
    on_path[src] = False
```



å…³é”®åŒºåˆ«åœ¨äºååºä½ç½®æ’¤é”€æ ‡è®°

ä¸ºå•¥ä¹‹å‰è®²çš„éå†èŠ‚ç‚¹å°±ä¸ç”¨æ’¤é”€ `visited` æ•°ç»„çš„æ ‡è®°ï¼Œè€Œè¿™é‡Œè¦åœ¨ååºä½ç½®æ’¤é”€ `onPath` æ•°ç»„çš„æ ‡è®°å‘¢ï¼Ÿ

å› ä¸ºå‰æ–‡éå†èŠ‚ç‚¹çš„ä»£ç ä¸­ï¼Œ`visited` æ•°ç»„çš„èŒè´£æ˜¯ä¿è¯æ¯ä¸ªèŠ‚ç‚¹åªä¼šè¢«è®¿é—®ä¸€æ¬¡ã€‚**è€Œå¯¹äºå›¾ç»“æ„æ¥è¯´ï¼Œè¦æƒ³éå†æ‰€æœ‰è·¯å¾„ï¼Œå¯èƒ½ä¼šå¤šæ¬¡è®¿é—®åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ˜¯å…³é”®çš„åŒºåˆ«**ã€‚

æ¯”æ–¹è¯´ä¸‹é¢è¿™å¹…å›¾ï¼Œæˆ‘ä»¬æƒ³æ±‚ä»èŠ‚ç‚¹ `1` åˆ°èŠ‚ç‚¹ `4` çš„å…¨éƒ¨è·¯å¾„ï¼š

![img](assets/graph-path.jpg)

å¦‚æœä½¿ç”¨å‰æ–‡éå†èŠ‚ç‚¹çš„ç®—æ³•ï¼Œåªåœ¨å‰åºä½ç½®æ ‡è®° `visited` ä¸º trueï¼Œé‚£ä¹ˆéå†å®Œ `1->2->4` å’Œ `1->2->3->4` ä¹‹åï¼Œæ‰€æœ‰èŠ‚ç‚¹éƒ½å·²ç»è¢«æ ‡è®°ä¸ºå·²è®¿é—®äº†ï¼Œç®—æ³•å°±ä¼šåœæ­¢ï¼Œ`visited` æ•°ç»„å®Œæˆäº†è‡ªå·±çš„èŒè´£ã€‚

ä½†æ˜¯æ˜¾ç„¶æˆ‘ä»¬è¿˜æ²¡æœ‰éå†å®Œæ‰€æœ‰è·¯å¾„ï¼Œ`1->3->2->4` å’Œ `1->3->4` è¢«æ¼æ‰äº†ã€‚

å¦‚æœç”¨ `onPath` æ•°ç»„åœ¨ç¦»å¼€èŠ‚ç‚¹æ—¶ï¼ˆååºä½ç½®ï¼‰æ’¤é”€æ ‡è®°ï¼Œå°±å¯ä»¥æ‰¾åˆ° `1` åˆ° `4` çš„æ‰€æœ‰è·¯å¾„ã€‚

ç”±äºè¿™é‡Œä½¿ç”¨çš„ `onPath` æ•°ç»„ä¼šåœ¨ååºä½ç½®æ’¤é”€æ ‡è®°ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°å¯èƒ½é‡å¤éå†å›¾ä¸­çš„èŠ‚ç‚¹å’Œè¾¹ï¼Œå¤æ‚åº¦ä¸€èˆ¬è¾ƒé«˜ï¼ˆé˜¶ä¹˜æˆ–æŒ‡æ•°çº§ï¼‰ï¼Œå…·ä½“çš„æ—¶é—´å¤æ‚åº”è¯¥æ˜¯æ‰€æœ‰è·¯å¾„çš„é•¿åº¦ä¹‹å’Œï¼Œå–å†³äºå›¾çš„ç»“æ„ç‰¹ç‚¹ã€‚

### åŒæ—¶ä½¿ç”¨ `visited` å’Œ `onPath` æ•°ç»„

æŒ‰ç…§ä¸Šé¢çš„åˆ†æï¼Œ`visited` æ•°ç»„å’Œ `onPath` åˆ†åˆ«ç”¨äºéå†æ‰€æœ‰èŠ‚ç‚¹å’Œéå†æ‰€æœ‰è·¯å¾„ã€‚é‚£ä¹ˆå®ƒä»¬ä¸¤ä¸ªæ˜¯å¦å¯èƒ½ä¼šåŒæ—¶å‡ºç°å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯èƒ½çš„ã€‚

éå†æ‰€æœ‰è·¯å¾„çš„ç®—æ³•å¤æ‚åº¦è¾ƒé«˜ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹æˆ‘ä»¬å¯èƒ½å¹¶ä¸éœ€è¦ç©·ä¸¾å®Œæ‰€æœ‰è·¯å¾„ï¼Œè€Œæ˜¯ä»…éœ€è¦æ‰¾åˆ°æŸä¸€æ¡ç¬¦åˆæ¡ä»¶çš„è·¯å¾„ã€‚è¿™ç§åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå€ŸåŠ© `visited` æ•°ç»„è¿›è¡Œå‰ªæï¼Œæå‰æ’é™¤ä¸€äº›ä¸ç¬¦åˆæ¡ä»¶çš„è·¯å¾„ï¼Œä»è€Œé™ä½å¤æ‚åº¦ã€‚

æ¯”å¦‚åæ–‡ æ‹“æ‰‘æ’åº ä¸­ä¼šè®²åˆ°å¦‚ä½•åˆ¤å®šå›¾æ˜¯å¦æˆç¯ï¼Œå°±ä¼šåŒæ—¶åˆ©ç”¨ `visited` å’Œ `onPath` æ•°ç»„æ¥è¿›è¡Œå‰ªæã€‚

æ¯”æ–¹è¯´åˆ¤å®šæˆç¯çš„åœºæ™¯ï¼Œåœ¨éå†æ‰€æœ‰è·¯å¾„çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœå‘ç°ä¸€ä¸ªèŠ‚ç‚¹ `s` è¢«æ ‡è®°ä¸º `visited`ï¼Œé‚£ä¹ˆè¯´æ˜ä» `s` è¿™ä¸ªèµ·ç‚¹å‡ºå‘çš„æ‰€æœ‰è·¯å¾„åœ¨ä¹‹å‰éƒ½å·²ç»éå†è¿‡äº†ã€‚å¦‚æœä¹‹å‰éå†çš„æ—¶å€™éƒ½æ²¡æœ‰æ‰¾åˆ°ç¯ï¼Œæˆ‘ç°åœ¨å†å»éå†ä¸€æ¬¡ï¼Œè‚¯å®šä¹Ÿä¸ä¼šæ‰¾åˆ°ç¯ï¼Œæ‰€ä»¥è¿™é‡Œå¯ä»¥ç›´æ¥å‰ªæï¼Œä¸å†ç»§ç»­éå†èŠ‚ç‚¹ `s`ã€‚

æˆ‘ä¼šåœ¨åé¢çš„å›¾è®ºç®—æ³•å’Œä¹ é¢˜ä¸­ç»“åˆå…·ä½“çš„æ¡ˆä¾‹è®²è§£ï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº†ã€‚

### å®Œå…¨ä¸ç”¨ `visited` å’Œ `onPath` æ•°ç»„

æ˜¯å¦æœ‰æ—¢ä¸ç”¨ `visited` æ•°ç»„ï¼Œä¹Ÿä¸ç”¨ `onPath` æ•°ç»„çš„åœºæ™¯å‘¢ï¼Ÿå…¶å®ä¹Ÿæ˜¯æœ‰çš„ã€‚

å‰é¢ä»‹ç»äº†ï¼Œ`visited` å’Œ `onPath` ä¸»è¦çš„ä½œç”¨å°±æ˜¯å¤„ç†æˆç¯çš„æƒ…å†µï¼Œé¿å…æ­»å¾ªç¯ã€‚é‚£å¦‚æœé¢˜ç›®å‘Šè¯‰ä½ è¾“å…¥çš„å›¾ç»“æ„ä¸åŒ…å«ç¯ï¼Œé‚£ä¹ˆä½ å°±ä¸éœ€è¦è€ƒè™‘æˆç¯çš„æƒ…å†µäº†ã€‚

æ¯”å¦‚ä¸‹é¢è¿™ä¸ªä¾‹é¢˜ï¼š



è¿™ä¸ªé¢˜ç›®è¾“å…¥çš„æ˜¯ä¸€ä¸ª é‚»æ¥è¡¨ï¼Œä¸”æ˜ç¡®å‘Šè¯‰ä½ è¾“å…¥çš„å›¾ç»“æ„ä¸åŒ…å«ç¯ï¼Œæ‰€ä»¥ä¸éœ€è¦ `visited` å’Œ `onPath` æ•°ç»„ï¼Œç›´æ¥ä½¿ç”¨ DFS éå†å›¾å°±è¡Œäº†ï¼š

java ğŸŸ¢cpp ğŸ¤–go ğŸ¤–javascript ğŸ¤–python ğŸ¤–



```python
class Solution:
    # è®°å½•æ‰€æœ‰è·¯å¾„
    def __init__(self):
        self.res = []
        self.path = []

    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        self.traverse(graph, 0)
        return self.res

    # å›¾çš„éå†æ¡†æ¶
    def traverse(self, graph: List[List[int]], s: int):
        # æ·»åŠ èŠ‚ç‚¹ s åˆ°è·¯å¾„
        self.path.append(s)

        n = len(graph)
        if s == n - 1:
            # åˆ°è¾¾ç»ˆç‚¹
            self.res.append(self.path.copy())
            self.path.pop()
            return

        # é€’å½’æ¯ä¸ªç›¸é‚»èŠ‚ç‚¹
        for v in graph[s]:
            self.traverse(graph, v)

        # ä»è·¯å¾„ç§»å‡ºèŠ‚ç‚¹ s
        self.path.pop()
```

å¯è§†åŒ–é¢æ¿ æ”¯æŒå›¾ç»“æ„çš„å¯è§†åŒ–ï¼Œä½ å¯ä»¥å¤šæ¬¡ç‚¹å‡» `if (s === n - 1)` è¿™ä¸€è¡Œä»£ç ï¼Œè§‚çœ‹ç®—æ³•çš„éå†è¿‡ç¨‹ï¼š



## å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰

å›¾ç»“æ„çš„å¹¿åº¦ä¼˜å…ˆæœç´¢å…¶å®å°±æ˜¯ å¤šå‰æ ‘çš„å±‚åºéå†ï¼Œæ— éå°±æ˜¯åŠ äº†ä¸€ä¸ª `visited` æ•°ç»„æ¥é¿å…é‡å¤éå†èŠ‚ç‚¹ã€‚

ç†è®ºä¸Š BFS éå†ä¹Ÿéœ€è¦åŒºåˆ†éå†æ‰€æœ‰ã€ŒèŠ‚ç‚¹ã€å’Œéå†æ‰€æœ‰ã€Œè·¯å¾„ã€ï¼Œä½†æ˜¯å®é™…ä¸Š BFS ç®—æ³•ä¸€èˆ¬åªç”¨æ¥å¯»æ‰¾é‚£æ¡**æœ€çŸ­è·¯å¾„**ï¼Œä¸ä¼šç”¨æ¥æ±‚**æ‰€æœ‰è·¯å¾„**ã€‚

å½“ç„¶ BFS ç®—æ³•è‚¯å®šä¹Ÿå¯ä»¥æ±‚æ‰€æœ‰è·¯å¾„ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸€èˆ¬ä¼šé€‰æ‹©ç”¨ DFS ç®—æ³•æ±‚æ‰€æœ‰è·¯å¾„ï¼Œå…·ä½“åŸå› æˆ‘åœ¨ äºŒå‰æ ‘çš„é€’å½’/å±‚åºéå† ä¸­è®²è¿‡ï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº†ã€‚

é‚£ä¹ˆå¦‚æœåªæ±‚æœ€çŸ­è·¯å¾„çš„è¯ï¼Œåªéœ€è¦éå†ã€ŒèŠ‚ç‚¹ã€å°±å¯ä»¥äº†ï¼Œå› ä¸ºæŒ‰ç…§ BFS ç®—æ³•ä¸€å±‚ä¸€å±‚å‘å››å‘¨æ‰©æ•£çš„é€»è¾‘ï¼Œç¬¬ä¸€æ¬¡é‡åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼Œå¿…ç„¶å°±æ˜¯æœ€çŸ­è·¯å¾„ã€‚

å’Œå‰æ–‡ å¤šå‰æ ‘å±‚åºéå† ä»‹ç»çš„ä¸€æ ·ï¼Œå›¾ç»“æ„çš„ BFS ç®—æ³•æ¡†æ¶ä¹Ÿæœ‰ä¸‰ç§ä¸åŒçš„å†™æ³•ï¼Œä¸‹é¢æˆ‘ä¼šå¯¹æ¯”ç€å¤šå‰æ ‘çš„å±‚åºéå†å†™ä¸€ä¸‹å›¾ç»“æ„çš„ä¸‰ç§ BFS ç®—æ³•æ¡†æ¶ã€‚

### å†™æ³•ä¸€

ç¬¬ä¸€ç§å†™æ³•æ˜¯ä¸è®°å½•éå†æ­¥æ•°çš„ï¼š





```python
# å¤šå‰æ ‘çš„å±‚åºéå†
def levelOrderTraverse(root):
    if root is None:
        return
    from collections import deque
    q = deque([root])
    while q:
        cur = q.popleft()
        # è®¿é—® cur èŠ‚ç‚¹
        print(cur.val)

        # æŠŠ cur çš„æ‰€æœ‰å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
        for child in cur.children:
            q.append(child)

# å›¾ç»“æ„çš„ BFS éå†ï¼Œä»èŠ‚ç‚¹ s å¼€å§‹è¿›è¡Œ BFS
def bfs(graph, s):
    visited = [False] * len(graph)
    from collections import deque
    q = deque([s])
    visited[s] = True

    while q:
        cur = q.popleft()
        print(f"visit {cur}")
        for e in graph.neighbors(cur):
            if not visited[e.to]:
                q.append(e.to)
                visited[e.to] = True
```



### å†™æ³•äºŒ

ç¬¬äºŒç§èƒ½å¤Ÿè®°å½•éå†æ­¥æ•°çš„å†™æ³•ï¼š





```python
from collections import deque

# å¤šå‰æ ‘çš„å±‚åºéå†
def levelOrderTraverse(root):
    if root is None:
        return
    q = deque([root])
    # è®°å½•å½“å‰éå†åˆ°çš„å±‚æ•°ï¼ˆæ ¹èŠ‚ç‚¹è§†ä¸ºç¬¬ 1 å±‚ï¼‰
    depth = 1
    
    while q:
        sz = len(q)
        for _ in range(sz):
            cur = q.popleft()
            # è®¿é—® cur èŠ‚ç‚¹ï¼ŒåŒæ—¶çŸ¥é“å®ƒæ‰€åœ¨çš„å±‚æ•°
            print(f"depth = {depth}, val = {cur.val}")
            
            for child in cur.children:
                q.append(child)
        depth += 1



# ä» s å¼€å§‹ BFS éå†å›¾çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¸”è®°å½•éå†çš„æ­¥æ•°
def bfs(graph, s):
    visited = [False] * len(graph)
    q = deque([s])
    visited[s] = True
    # è®°å½•ä» s å¼€å§‹èµ°åˆ°å½“å‰èŠ‚ç‚¹çš„æ­¥æ•°
    step = 0
    
    while q:
        sz = len(q)
        for i in range(sz):
            cur = q.popleft()
            print(f"visit {cur} at step {step}")
            for e in graph.neighbors(cur):
                if not visited[e.to]:
                    q.append(e.to)
                    visited[e.to] = True
        step += 1
```

åœ¨è¿™ä¸ªå¯è§†åŒ–é¢æ¿ä¸­ï¼Œæˆ‘å¯¹ `step` ä¸åŒçš„èŠ‚ç‚¹è®¾ç½®äº†ä¸åŒçš„é¢œè‰²ï¼š



è¿™ä¸ª `step` å˜é‡è®°å½•äº†ä»èµ·ç‚¹ `s` å¼€å§‹çš„éå†æ­¥æ•°ï¼Œå¯¹äºæ— æƒå›¾æ¥è¯´ï¼Œç›¸å½“äºæ¯æ¡è¾¹çš„æƒé‡éƒ½æ˜¯ 1ï¼Œè¿™ä¸ªå˜é‡å°±å¯ä»¥è¾…åŠ©æˆ‘ä»¬åˆ¤æ–­æœ€çŸ­è·¯å¾„ã€‚

### å†™æ³•ä¸‰

ç¬¬ä¸‰ç§èƒ½å¤Ÿé€‚é…ä¸åŒæƒé‡è¾¹çš„å†™æ³•ï¼š





```python
# å¤šå‰æ ‘çš„å±‚åºéå†
# æ¯ä¸ªèŠ‚ç‚¹è‡ªè¡Œç»´æŠ¤ State ç±»ï¼Œè®°å½•æ·±åº¦ç­‰ä¿¡æ¯
class State:
    def __init__(self, node, depth):
        self.node = node
        self.depth = depth

def levelOrderTraverse(root):
    if root is None:
        return
    from collections import deque
    q = deque([State(root, 1)])
    while q:
        state = q.popleft()
        cur = state.node
        depth = state.depth
        # è®¿é—® cur èŠ‚ç‚¹ï¼ŒåŒæ—¶çŸ¥é“å®ƒæ‰€åœ¨çš„å±‚æ•°
        print(f"depth = {depth}, val = {cur.val}")
        
        for child in cur.children:
            q.append(State(child, depth + 1))


# å›¾ç»“æ„çš„ BFS éå†ï¼Œä»èŠ‚ç‚¹ s å¼€å§‹è¿›è¡Œ BFSï¼Œä¸”è®°å½•è·¯å¾„çš„æƒé‡å’Œ
# æ¯ä¸ªèŠ‚ç‚¹è‡ªè¡Œç»´æŠ¤ State ç±»ï¼Œè®°å½•ä» s èµ°æ¥çš„æƒé‡å’Œ
class State:
    def __init__(self, node, weight):
        # å½“å‰èŠ‚ç‚¹ ID
        self.node = node
        # ä»èµ·ç‚¹ s åˆ°å½“å‰èŠ‚ç‚¹çš„æƒé‡å’Œ
        self.weight = weight


def bfs(graph, s):
    visited = [False] * len(graph)
    from collections import deque

    q = deque([State(s, 0)])
    visited[s] = True

    while q:
        state = q.popleft()
        cur = state.node
        weight = state.weight
        print(f"visit {cur} with path weight {weight}")
        for e in graph.neighbors(cur):
            if not visited[e.to]:
                q.append(State(e.to, weight + e.weight))
                visited[e.to] = True
```

å¯¹äºåŠ æƒå›¾ï¼Œç”±äºæ¯æ¡è¾¹çš„æƒé‡ä¸åŒï¼Œéå†çš„æ­¥æ•°ä¸å†èƒ½ä»£è¡¨æœ€çŸ­è·¯å¾„çš„é•¿åº¦ï¼Œæ‰€ä»¥éœ€è¦æ¯ä¸ªèŠ‚ç‚¹ç”¨è‡ªå®šä¹‰ `State` ç±»ç»´æŠ¤è‡ªå·±çš„è·¯å¾„æƒé‡å’Œï¼Œæœ€å…¸å‹çš„ä¾‹å­å°±æ˜¯ Dijkstra å•æºæœ€çŸ­è·¯å¾„ç®—æ³• äº†ã€‚

åœ¨è¿™ä¸ªå¯è§†åŒ–é¢æ¿ä¸­ï¼Œæˆ‘åˆ›å»ºäº†ä¸€å¹…åŠ æƒå›¾ã€‚ä½ å¯ä»¥å¤šæ¬¡ç‚¹å‡» `console.log` è¿™ä¸€è¡Œä»£ç ï¼Œæ³¨æ„å‘½ä»¤è¡Œçš„è¾“å‡ºï¼Œè¿™ç§å†™æ³•å¯ä»¥åœ¨éå†èŠ‚ç‚¹çš„åŒæ—¶è®°å½•èµ·ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼Œè¿™æ˜¯å‰ä¸¤ç§ BFS ä»£ç åšä¸åˆ°çš„ï¼š