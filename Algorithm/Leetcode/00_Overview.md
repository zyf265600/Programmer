# 1.算法就是程序员的驾照

> 本关我们先来聊一聊如何应对算法。
> 算法就是程序员的驾照，你可以认为算法有用，也可以认为没用，但是随着互联网越来越卷，如果算法不行，会错失很多机会，在互联网的道路也走不远。



## 1.1 什么才是职场亮点 

在算法班，有位同学分享过一个让人震惊的信息。他说一个女孩去面试，在简历的个人优势部分里写自己不孕不育，不需要产假。这个是优势吗？我问几个女同事，她们竟然对此表示认同，至少不反对。很多女生面试时也会被反复问及家庭和婚育方面的问题，甚至因此过不了面试，可见职场多么残酷！

可问题是，不孕不育是亮点吗？我们是求职，但不是牲畜，也不是机器。每个人都有追求幸福的权利，为了家人、为了孩子， 我们更有动力去工作。这个女孩内心一定会有深深的失落，这种失落不会化为认真工作的动力，只可能变成熬时间的浑浑噩噩。认真只能将事情做对，用心才能将事情做好。一个合格的老板应该鼓励她该看病就好好看病，回来就认真工作，只关注考勤和工作时长的公司不是好公司，特别是重在脑力劳动的互联网公司。

这件事也告诉我们想打造一个亮点是多么难，在简历上加一条要付出多大的代价。有人会说 ，我简历每次都写很多，有啥难的。难在是写了很多，但是经不住面试的考验，不足以证明你的能力，不足以让你超越其他求职者，不足以让公司认可你。

那问题说回来，什么才算亮点呢？我们知道校招主要看：学校与成绩、过往亮点和技能水平。而对于社招，主要考察三个显式方面：项目、技术和算法，还有两个隐式方面：学历和上一家公司的档次。 

显式的意思就是面试可以聊，而且能直接反应你客观水平的。隐式条件是双方不会怎么说，但是大家心照不宣，而且你也无法改变的。所以，项目经验丰富是亮点，技术水平过硬是亮点，算法能力强是亮点、学历高学校好是亮点，上家公司好也是亮点。面试就是战场，将所有的亮点摆出来，就看谁能走到最后。

能否面试成功、能要到多少的薪资 ，很多时候是看你值多少钱，而不是多么能加班。经常在各种群里看到抱怨如何如何被歧视，参加线上交流的时候几乎每次都有人问两个隐条件，平时也经常有人反复问：想去大厂，专科有机会吗？外包有机会吗？小公司有机会吗？等等。事实上，告诉你有和没有有啥区别吗？你能做什么吗？什么都做不了！可以告诉你100个没有机会的理由，也可以告诉你100个有机会的例子，我至少有五位同事都是普通学历，但是进了微博美团等大厂。

你会花几年重新高考吗？你能让时光倒流，重新冲击大厂吗？如果不会，纠结这个问题有什么意义呢？你应该做的是认清现实，先接受现在的自己，然后想着接下来该怎么做才能让自己更强，才能让自己获得更好的机会！

![image.png](assets/1688656401302-dd93bc1f-8d20-4837-8c55-d765fea7175b.png)



学历歧视是普遍存在的，只是没有哪个公司敢直接说而已，各行各业都这样，大家都心知肚明。爱美之心人皆有之，如果选择贾玲和杨幂做你老婆，你会选择谁？我们都知道贾玲非常优秀，非常幽默，人品又好，还很会挣钱，所以我选择杨幂，原因就一个：杨幂漂亮！如果两个求职者面试情况非常接近，一个是阿里来的，一个是某个谁都不知道的小公司来的，你更想要谁？这是人的本性，我们无法改变。如果换位，我们也可能是那个我们讨厌的人。

相对而言，研发岗位更注重真才实学，即使你学历高学校好也不见得就一定能行，如果技术不清不楚，算法也写的不好，那学历就是个摆设，机会还是没有，这种例子也非常多。另一方面，很多公司在缺人的时候会降低隐性要求，给你一个面试的机会。那接下来就看你面试的表现了，项目水平、技术深度和算法能力就真刀真枪来一遍。遗憾的是很多人在面试过程中软绵绵的，技术说不清楚，算法写不出来，甚至直接放弃，那对方怎么给你机会呢？

我们都知道算法费脑子，但是要去大厂、要拿高薪，这是必须要过的坎。

遗憾的是很多人 ，特别是在算法班，很多人交完钱就不见了。

不少人快面试的时候才想起来算法弱，然后急着问怎么办。别人能怎么办？要是3天就有办法解决，那我们的课就不标价几百了，而标几万，我相信愿意来的人更多。

当前互联网行业机会还是很多的。是金子，一定能找到发光的地方，前提是把自己训练成金子。为什么是训练呢？因为如何面试、如何学技术，包括我们接下来要谈的算法等都是有科学的方法可以训练的，只要将相关的能力训练出来就行了。

所以如果以后再有人问起点一般有没有机会去大厂，我就直接问“算法如何”，如果说不会，那就直接告诉他没有机会。反之，则鼓励他，积极关注，有机会就去冲刺！



## 1.2 算法就是八股文 

那算法这么费脑子，平时感觉自己还挺聪明的，一到算法就感觉智商为0， 该咋办呢？

我可以明确告诉你，面试官也是刷题过来的，大部分面试都是以常见题目为主，而常见的算法题是有限的，常考的题目类型也是固定的，因此你只要将我当成驾照一样，集中一段时间将其学会就行了。

==学会这些不是要百分百过一切面试，而是做到80%以上的题目都能搞定就行了。==我们的课程也绝不会说让你一定能解决所有的算法，那你需要海量的时间和精力，我们的目标就是让你用最少的时间搞清楚80%的问题，剩下的时间学技术、做项目更有意义。那如果遇到奇葩面试怎么办呢？不用怕，大不了问候一下他祖宗，换下一个公司就是了。

很多人想学算法，觉得对工作非常有用，所以要学好，所以要好好刷LeetCode。我可以告诉你LeetCode里的算法是没啥用的。你在工作中有写过链表吗？有写过二叉树吗？有自己实现过回溯吗，有写过动态规划吗？反正我从来没有。因为这种代码不易扩展 ，很难维护，如果在工作中写，一定会被骂，但是在算法里是绝对的重点。

那算法有什么用呢？其实就是练习思维的游戏，说白了就是面试用的。那话又说回来，为什么面试非要现场写算法呢？因为算法是测试你是不是金子的最有效手段。这种方式不是完美的，但是最好的。

我也曾经很排斥，但是当我作为面试官去面别人的时候才感觉到为什么非要这样。从一开始我就努力识别这个人的水平到底怎么样，我会分析项目里哪些是他自己做的，哪些是他真正理解的，哪些是他背的。 但只有让对方写个难度中等的算法，看他在整个过程中的表现，我才会放心他的基本功是不是扎实的。

为什么呢？因为算法是所有程序员的共同语言。虽然都是做java，大家的行业和具体的事情千差万别，很难准确判断一个人到底水平如何，说不定他说得天花乱坠的设计，最后只是写了个if else。做CPU指令的人也不太可能懂前端小姐姐说的vue是什么。做网络的面试官可能对擅长数据库的求职者也没什么感觉。数据结构与算法就成了双方都能交流的领域，而且好坏立竿见影，不管怎么说，能写出来，能运行出来就是真功夫。对于大厂以及很多还不错的公司，算法成了面试的一个必备环节，有的面试官只有亲自考你一个才放心。

所以， 算法这东西就当做驾照，常见不过十几种专题，300多道常见问题，将当做要掌握的一种必备技能就行了。反之，一直回避，不想下功夫，却天天抱怨，每次换工作都要被折腾一圈，即使大厂招人，很多人也压根就没机会。



## 1.3 关于算法面试的一些误区 

对于算法，有很多很多的论调，有的还截然相反，这里看几个。我们都不喜欢说教，但是在和很多小伙伴聊的时候都发现存在一个或几个问题，这会影响学习效果，干脆就统一列举一下吧。观点没有好坏，希望能帮你进一步审视算法。

### 1.3.1 学而不思，思而不学

经常有人说花了3小时写了一个算法，这样不好说不好，只能说效率太低，偶尔干一干还是可以的。很多算法的方法是固定的，完全靠自己想出来费时费力，即使写出来的，不管结构还是设计上可能非常差，而且很容易就忘了，面试时即使考原题还是一样懵逼。比如在《位运算》一关，我们会介绍很多技巧，这些靠自己面试时临时想出来几乎不可能，这就是典型的思而不学。

还有人是另一个极端，有的人说自己刷了200题，还是感觉很迷茫，我非常怀疑他根本没有刷清楚，可能只是跑了一下别人的答案而已。如果刷过一定量的题，一定会发现大量的考察点是重复的，很多问题本质上是一个东西，所以题目是越刷越少的，甚至还能自己出题，怎么会越来越迷茫呢？

那学和思怎么划分呢？我的感觉做题以半小时为界限，如果半小时后还想不到怎么做，就该找别人的解析来学习。

### 1.3.2 抬头仰望星空，低头不断抱怨

很多人愁算法的时间比真正练习的时间更长。不知道大家在学生时代是否一直为如何学好英语犯愁，整天各种疯狂英语，各种新东方，但是一直到毕业也没将英语真正学好。为什么？一个原因就是天天喊着要学习英语，但从来没做过，更别说坚持。

算法也一样。还有的人马上要面试了，才急着找个佛脚抱抱，平时根本不关心。有的人会一时兴起，随便选一道题来考察自己算法到底行不行，十有八九是失败的，因为一道题可能涉及了hash，涉及了树，涉及了递归，结果你连怎么定义树节点都不知道 ，怎么可能解决呢，最后必然是打击自己。

这就好比很久没运动了，突然让跑一万米，谁能跑下来？

### 1.3.3 总想着一步登天，一劳永逸

有的人想着从0开始，于是就找了本厚厚的数据结构书看。但是大部分人会对这类书没什么感觉，更不会坚持看完，于是没多久就不了了之。有的人发誓要将leetcode全部刷完，彻底解决算法问题，然后从第一题开始向后刷，要知道LeetCode里靠前的题目普遍比较难的，因此费劲好大也没刷几道，信心没有了，不想刷了，甚至心生畏惧，最终算法成了过不去的痛。

有的人希望算法能达到熟记的程度， 抬手就能来，这是不可能的，我们重点在于理解清楚，面试的时候给你点时间就能想明白、写出来，而不是全部熟记才算。

还有的人总是感觉动态规划才叫算法，回溯才叫学算法，而不重视基础问题。其实是认为高难度题目都会了，基本问题还是事。

这就像总想着娶白富美， 对自己身边的女孩漠不关心，那注定孤独一生。面试过程中大部分算法是以基础问题和变型问题为主的，有点难度，但是不会难于登天。如果只盯着难题，往往会难题搞不清楚，基本问题又不会，也许这就叫走火入魔吧。

另一方面，如果将基础问题、经典问题、常见套路等掌握了， 会发现很多所谓的难题是可以拆解的、转换的，到了最后，仍然是基本问题了。很多从小成绩好的同学都是这么学的。

### 1.3.4 因为外在吹牛而焦虑

例如喜欢看一些如何刷算法的毒文章，有些会推荐一堆的书，特别是《算法导论》。我觉得这种人真该死，因为这本书虽然叫导论，但比一般的算法书要难很多，没有足够的数学功底根本看不了。起点不高的人看了会迅速失去信心，因此这类书对大不部分人来说根本不适合，这种毒文无疑也让人坚信算法天生是难的，更别说乐趣。没有乐趣的学习，注定无法持久的。

还有人对群里那些炫耀特别敏感，有些面过大厂的人为了提高自己的逼格，会极度渲染面试的紧张，比如30min必须写完，要当着面试官的面写完，远程时面试官盯着你的桌面让你写等等。事实上，在面试官面前写算法，如果你一直没有思路，有些面试官会提醒你的。如果你的思路有问题，他也会提醒的，方案没有问题才会让你去写，这无疑会降低你写算法难度的。

所以面试官盯着你，你就当成一个高手在指导你就行了，何必这么紧张。那些人渲染面试多么紧张会给别人带来极大的恐慌和焦虑，所以这种人我是看到一次怼一次，绝不客气！

### 1.3.5 总感觉以后在工作中多积累一些算法就行了

事实上面试算法和工程算法的侧重点是完全不一样的，相互之间的关联非常少。我们在后续章节中会看到大量这样的例子，例如工程中会大量使用Hash，因为简单好用又稳定，但是很多算法一旦使用Hash就没有含金量了。

所以在面试算法里，Hash只是个备胎，只要有其他思路一般就不用了。在工程应用中我们追求的是易用性和稳定性这些，而算法更多考察思维能力而不怎么管是否能用。所以必须针对面试算法做一定的积累，指望工作中积累只会是幻想。

### 1.3.6 工作事多、平时很忙，没时间学习

别说没时间，因为这只是借口，对自己不够狠。我读研时曾经有位博士，有机会去斯坦福大学。当时他只有3个月的时间来准备英语，还有科研任务在手，而当时他连6级都没过，怎么可能在3个月内达到要求呢？于是他报了新东方的培训班，坚持上课学习，然后每天早上5点起来练英语，就这样一直坚持，直到考完。后来回国后，一个公司给开年薪150W，结果人家没看上。你觉得让他脚本会更快吗？让他做需求会更好吗？加班时间会更长吗？那凭啥人家的薪资是我们的几倍甚至十几倍？因为他档次高！关键时刻他能顶住压力做到常人做不到的事。

薪资水平不仅仅取决于工作时长，更多是自己的档次和展现出来的能力，让人相信你值这个价。一直强调自己能加班，反而显得自己技术水平不够。虽然大部分都不会在工作中用，但是算法本身就是思维能力的一种证明。不会做就不给加钱，做出来就敢多要几千，就这么简单。

### 1.3.7 试图死记硬背答案

算法有没有模板？有的，而且还很多，越是高级的算法越有模板，例如二分查找、各种牌组方法、数字、位运算、双指针、滑动窗口、回溯、动态规划等等都有自己的模板，而前缀树、线段树、堆、平衡树等等本身就是一套规则，理解规则了，题目几乎都不用做。

既然有模板那是否可以背一下呢？那就错了，模板是思想一致，解题思路一致，而具体的代码则千变万化，不可能记住的。而且稍微换一下条件就可能修改好多代码，因此靠背答案是没有任何意义的。

比较靠谱的是先透彻理解算法的思想，一题一题做，将技能和技巧总结出来，最后将题目归类总结出本类型题目的解题套路，这就是模板，我们后面几乎每个章节都是这种方式进行的。





# 2.怎么准备算法和应对算法

> 本文我们先来聊一聊算z法的边界再哪里，如何准备算法，以及如何刷算法题



## 2.1 算法的边界是什么 

### 2.1.1 算法到底考什么 

上面说了这么多，那算法到底考察什么呢？我们来分析一下。

首先算法有校招和社招两种情况，校招算法的首要目的是什么呢？刷人！每年投阿里头条的可能有十万几十万，面试官不能一个个去面吧，那怎么办呢？用一些难的算法干掉一大波人，剩下的再择优录取，所以你在网上看到的什么阿里秋招、头条春招试题集里的算法都挺难。

而对于社招，或者校招的时候扛过了笔试进入了面试环节，只要你简历筛选通过了，就说明他愿意放下各种外在因素，考察一下这个人的功力如何，能力怎么样，而算法只是考察思维能力的一部分，不是为了刷人而刷人，因此不会像校招这么变态。

在面试的时候还要考虑时间因素，两个小时还没写出来，面试官自己都坐不住了。要知道面试官也是开发者，他可能正在忙着做需求、查bug，只是被HR临时叫来面试，他能接受的算法时间也就半小时左右。因此社招面试会以中等问题为主，时间在20~40min为主。

社招面试考点主要有三个：

●  这个人的==编程基本功是否扎实==，基本功不扎实，写的代码可能到处是bug；

● 这个人的==编码规范性如何==，如果很混乱，边界、异常等处理不清楚，那承担的任务肯定让人不放心的；

● 这个人==思维能力如何==，是否能短时间内解决问题。这反应的就是平时遇到问题是否能够很好的解决掉，而不是天天无能为力。

由此面试算法的特点是：

1. 能够让面试者在20~40min左右完成。

2. 基本数据结构的变型题，有思维含量，但不会太难太偏。

3. 代码精简，50行以内就能解决问题。

根据上面三点，我们就可以认为不是所有算法都会考，刷算法也不是什么都刷，而应该更有针对性。看三个美团

例子：

![image.png](assets/1688656480927-36b63559-c0a5-49f3-8bc1-32be86cb5771.png)

自己经历的例子：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1670963/1688656502968-0c704c61-a400-4c14-bf79-1452f272c034.png)

这几个问题感觉如何？其实都是基本数据结构的拓展，不是晦涩难懂的动态规划什么的。这类题目在算法中能占到80%以上，所以大部分情况下只要掌握这些基本内容，就不用怕大部分的算法面试。



### 2.1.2 什么时候会出现难题呢？ 

有以下几种情况：

1. 校招的时候，上面已经说了，不再赘述。

2. 有些公司会先让你做个笔试题，或者提前上机写算法，通过之后才通知你去面试。这时候面试官不用考虑浪费自己时间的问题，可以给你两三个小时让你一直做，那这时候算法题的难度就会高很多。

3. 面试官不喜欢你，想让你走，可能会说你水平不错，但是我们更需要高级开发工程师等等。这不扯淡吗？招聘公告里压根就没说好不。 或者公司都快不行了，招人只是个噱头。公司的起起伏伏、生生死死太厉害了，比如今年去滴滴面，你觉得他们是真的需要人吗？这也说明，很多时候不见得是你的问题，而是对方的问题。

4. 面试官不会出题，我们不要觉得自己来面试就低人一等，面试是双向选择的过程，很可能是面试官经验不够不会出题，这就导致题目比较偏。

而我们在网上经常看到某某地方算法变态、或者直接抛出一个巨难无比的算法，说是哪里的面试题，问怎么做。这种信息就是垃圾，连搭理的必要都没有。

你绝对不会因为清华北大的考试难就不让你孩子上学吧？你也绝不会为了去大厂将所有的算法都学会吧。你也绝不会有百分之百的把握才会出去面试吧。我们学习更多是为了将算法面试的成功率从全靠运气变成80%的题目都会做，这就够了。

那该掌握多少算合适呢？

==我的观点是数据结构以及相关变形、拓展问题要掌握，大约150道核心题目。==

==高级专题要掌握滑动窗口、BFS、前缀树、数字和部分数学问题、回溯、贪心、动态规划等等大约200道核心题目。==

假如超出这些呢？实在做不来该怎么办呢？先尽力而为，不行就直接走人。这个公司很好吗？给的很多吗？加班很少吗？不然的会凭什么让我花那么多精力准备没用的算法! 所以实在没办法，就当走路的时候踩到狗屎了，换个公司继续面。



### 2.1.3 算法的来源 

很多东西难只是我们感觉难，如果明白其体系结构，循序渐进学习，很多事情就没那么难了。我们现在就看一下算法的体系到底是什么。要看体系，我们要先知道算法题是怎么来的，例如LeetCode2500多道题都是怎么来的。

我们经常看到”数据结构与算法“这样的名字，算法就是解决具体问题的步骤，例如遇到喜欢的女孩子，怎么追就是个算法问题；为了不迟到，你需要几点出门也是算法问题。算法更多的是思想，而数据结构是实现算法的载体，不管你的算法多么复杂，如果要计算来处理，最后都要落实到数组、链表、树、图等基本的结构上。

从上面这个关系，就可以看到算法命题的两条主线。第一条是基于数据结构的基本操作进行组合、变换和拓展。例如链表有增删改查四种基本操作，组合一下就有了经典的链表反转问题，这个问题长期霸占算法面试top1的位置，而链表反转又可以变换出指定区间反转、K个一组反转、两两反转等问题。还可以继续拓展出链表相加等算法问题。

事实上，所有数据结构的基本操作都是增删改查，基于此可以拓展出大量的问题，LeetCode中有一大半的题目都是这么来的。而这些问题难易适中、题干精简，非常适合面试，因此这也是我们后面学习的重点。

现实中，一个问题一个解法，但是很多问题的处理思路往往是一样的，所以很多人不断将一些通用方法进行总结和归纳就产生了针对特定场景的解题思想。例如暴力也无法解决的问题可以考虑使用回溯思想，为了防止数组中频繁对大量元素进行移动而产生了”双指针思想“。而将一些常用思想汇集起来就是我们常说的算法，例如广度优先搜索、深度优先搜索、滑动窗口、回溯、贪心、动态规划等等。这类问题往往比较难一些，关键在于我们对这些思想的理解没那么透彻，对其适用范围和常见问题也不太清楚，所以才会觉得难。

上面两种是绝大部分算法的来源，也是我们学习的重点。除此之外，还有两种常见的途径：

第一个，算法是个巨大的数学问题，比如数学里有《数论》《矩阵论》《概率论》《图论》《离散数学》《数值计算》《近世代数》《有限域》《最优化算法》等等，而如何用代码实现，都可以作为一个算法问题。但是这些领域过于专业的东西，我们基本用不到，常用的也就一些基本的内容。所以将这些科目的基本问题聚合到一起，就变成了算法的常见考题。例如在《数学》一章，我们只会涉及初等数论、位运算和矩阵等一些基本问题，而不会去研究有限元、椭圆曲线方程这些。这类题目在面试中占比不算高，但是在校招中不少。

其次，就是根据很多实际问题抽象而来，各个大厂对外公开的算法题里大量存在这种问题。例如小米的《风口的猪-中国牛市》、美团的《病毒传播》、快手的《获得最多的奖金》等等。这些问题灵活多变，需要我们根据文字描述建立模型，最后再编码实现，因此难度一般来说要大一些。这类问题一般出现在笔试或者加试过程中，进入面试环节了，就不用管了。



## 2.2 如何刷题 

我们明确了范围之后，接着就是按图索骥，逐个突破了，具体来说，在刷题的时候有以下几点方式会大大提高学习的效果。

### 2.2.1 按照专题刷，一招多题 

首先，目前==公认最好的刷算法就是按照主题来进行==，这也是最科学的方法。例如双指针系列、链表反转系列等等。算法题的聚集效应非常明显的，例如二叉树的层次遍历搞定了，连续十几道相关题目看一看就行了。而会了一个滑动窗口的模板，连续12道算法题也一晚搞定。这样坚持一段时间之后，再做新题就是不断完善自己的这个体系，而不是越做越糊涂。 

一个好的课程自然是要帮你梳理清楚这些专题，让你用最短的时间就能掌握，这也是我们课程一直在努力做的事。

### 2.2.2 用大白话理解问题 

算法不会，我们会感觉是自己不行，但是很多时候是因为别人写的东西为了提高逼格，弄的高大上。最典型的就是罗列一堆晦涩词汇。很多人一看动态规划就想着最优子结构，一看滑动窗口就盯着“循环不变量”不放，一提到红黑树就开始讲5大特征，那一定是学不好的。因为==专业名词是减少专业人士之间的废话的，而不是给小白看的。==我认为这也是国内很多教材让人看不懂的一个重要原因。如果你对孩子反反复复说“大型雌性猫科动物”，你解释一天他也不知道你在说啥，而找个母老虎的照片给他看一下，秒懂！

所以说，很多时候学不会，不是傻*，而是写材料的人在装*。如果从问题的本源开始梳理，很多东西都是很简单的。比如动态规划里的记忆化搜索，不过就用了一个数组保存已经计算出来的结果而已，而回溯代码的框架不过是遍历N叉树而已。

在我们的课程里，我会努力用最易懂的语言来解释算法。这是一个持续的过程，相关的工作我一直在做。

### 2.2.3 多画图，每个题目就是一个图 

==任何算法都是一个图，可能是结构图，也可能是时序图，只有这个图在大脑里构造出来了，我们才真的明白==，与看了多少文字，刷了多少题目关系不大。而且只有图能在大脑里长期存在，如果脑子里想清楚了，下次面试时，找来复习一下就行了。

这里解释了一个问题，就是学到什么程度才叫”学到家了“呢？有时候我们会感觉虽然学了一遍，但还是不放心，总感觉还是不会。我认为一个标准就是是否将这个问题的图在大脑里勾勒清楚了。比如二叉树的层次遍历执行过程是什么样的？元素大致怎么移动的？怎么来将每层分开？这些想清楚了，过几个月仍然会记得。而不是每行代码都记得才叫练算法。

图勾勒出来之后，我们以后换工作花在算法上的时间精力会越来越少。我们自然可以拿更多时间准备架构等更高级的东西，所以才能要更高的薪资，而不是每次都为基本问题搞不定而浪费时间。

我们的课程里也一直在努力做到这一点，不过这是一个庞大的工作，课程中会有一些瑕疵，如果发现问题了，请及时和我说。 

### 2.2.4 先在纸上手写，再上机 

这是我的个人感受，很多人一看算法就打开LeetCode开始调，要知道程序要在LeetCode里运行起来要解决环境、定义、边界以及几十个case都过才行，这并不是一个简单的事情，很多时候我们只能跑通几个case。在学习算法的初期，我们不必太介意过了几个case，而应该先关注我们是否将算法的思想理解清楚了，因此在纸上手写，或者使用Idea、pyCharm这种编译环境测试几个case就可以了。



## 2.3 面试时怎么写算法 

面试虽然在考算法，但是更多是考察思维水平的，而且很多面试官靠的是对你的感觉，感觉不好，即使最后写出来了也不一定会要。因此要注意与面试官交流，让其有个好的面试体验，否则就会随便找个理由将你打发走。比较可行的操作是：

==**● 第一步：理解问题，复述问题进而明确问题。**==

面试官说完之后，不要急着写，而是先复述一下你对问题的理解，这样可以防止理解错误，平时我们做需求也是这样的逻辑。

==**● 第二步：进一步确认问题，并大胆说出想法，逐步找到最优想法。**==

很多面试官不见得会将问题描述很清楚，这时候你的思考和引导会极大影响面试官对你的认可程度。例如：

![image-20231105154513470](assets/image-20231105154513470.png)

这时候我们会发现问题与我们最初理解的非常不一样，对一个包含一百万条年龄进行排序和对100个随机的数据排序方法会差很多很多。很多人会上来就想到教科书上的几种排序方法，那就错了。

确定了之后，那这时候我们就可以在大脑里快速想一下所有的数据结构、算法思想，想想哪些能解决这个问题。对于本题，人的年龄一般不会超过150岁，因此创建一个大小为150的数组，索引就是年龄，值就是统计值，遍历一下这一百万就可以得到最终结果。

将这个想法和面试官说了之后他没有异议才可以写，反之则必须先努力想，直到想清楚再下笔。

==**● 第三步：初步设计，先写整体，再考虑边界**==

算法的设计可能会比较困难，我们一时难以考虑周全，此时可以先将核心代码写出来，再逐步考虑忽略边界和一些异常情况，这个只能靠平时多积累。第一次写的时候不要怕乱，完成之后是可以和面试官打个招呼，然后重新誊写一遍的。

代码里重要的扣分点就是边界情况的处理和特殊场景的解决，很多人都会栽在这上面，如果有一个两个，面试还会提醒一下，如果太多，算法就废了。这个也只能靠平时的积累。在我们的讲义里会将每个算法可能的情况都告诉你。例如字符串转整数问题，看似简单，但是要处理五六种可能的情况，忘记两种就废了。

如果代码已经交给面试官了，你也要继续思考，如果发现哪里有问题，是可以直接和面试官说的，及时补救也是你思维活跃的表现。

==**● 第四步：测试检验，评判性能，优化解法。**==

如果是线上面试，很多时候算法是要能跑过的，测试的调试过程可能会麻烦不断，这时候只能硬着头皮上了。这时候一定要淡定，不用像热锅的蚂蚁一样这里修修那里改改，这样只会越来越乱，反而让面试官感觉你不行。

如果很幸运都跑过了，此时可以继续和面试官聊你想到的其他方法或者技巧，另外这时候经常会讨论一个非常重要的问题：时间复杂度和空间复杂度分析，这是评价算法好坏的重要指标，一般算法写完之后都会和面试官简单聊一下当前算法的复杂度情况。

平时刷算法的时候就要注意每个解法的时间复杂度和空间复杂度是什么。这其实是个比较简单问题，为了节省篇幅，我们大部分题目并没有太强调，但是自己刷题的时候要注意。

另外再强调一个问题，代码写的时候命名要专业一些，不要随便用 a ,b这种，尽量使用 int left,right等这种有意义的。命令问题很大程度反应了这个人的专业程度。在java里一般使用驼峰命令法，都使用英文单词，第一个单词全部小写，后面的单词首字母大写。





# 3. 关于算法需要的编程语言能力

很多开始学习算法的小伙伴都会问什么样的语言基础才可以学习算法？例如，我是C++方向，是不是要先将STL等学完才可以？

其实在算法里只会使用非常少的语言知识。而且平时练习的时候要尽量使用简单的语法，而且老师强烈不建议大家使用复杂的语法结构、第三方包等等。

为什么呢？因为面试的时候给你一个白板？你怎么加其他库？你记得名字吗？你知道怎么用吗？考试环境支持吗？等等都是问题，所以我们要坚持底线思维，就是万一遇到问题，自己也能手写出来。而不是练习只顾爽，面试的时候发现是瞎忙。

如果自己确实没有太多语言功底，那该怎么准备呢？

我曾尝试为C++、Java和Python写几个基础文章，但是后来发现，材料实在太多了，没必要在这方面花功夫。下面给大家画画重点：

参考教程：https://www.runoob.com/?frm=msidevs.net&tg=%CB%F7oE

在这里有很多语言的基础教程，还是非常不错的。

![image.png](assets/1693109727122-3d69a762-6dc3-44a5-970e-5199ca1bd771.png)

你会这些基础操作就差不多了。

有些同学可能会抬扛了，不对啊，我刷某某题的时候，用到了一个很复杂的**。这种情况能有几次，遇到的时候再说嘛。





# 4. 时间复杂度和空间复杂度问题

> 本文我们来理解一个非常重要的概念，复杂度问题。这个概念其实很简单 很多人经常感到很蒙，本文我们就来白话讲讲。
>
> 面试的时候怎么考呢？一般有两种方式：
>
> 1. 一个是要求你的算法满足特定的时间或者空间复杂度要求。例如同一个问题，有的解法时间复杂度是O(n^2),有的是O(n)，那这时候面试官可能会要求你的算法时间复杂度满足O(n)，或者空间复杂度满足O(1)。这时候你要理解面试官的意思。
> 2. 让你对不同的实现方式的做评判，典型的是不同的排序有不同的复杂度，让你来评判，详见排序一关。
>

 

## 4.1 时间复杂度 

### 4.1.1 算法如何度量 

看新闻，我们经常听到GDP，国内生产总值，这个是衡量经济发展状况的基本指标。在公司里，经常听到KPI考评等指标。所以很多事物都需要一个相对客观的衡量标准来评价好坏或者差异。对于算法，最重要就是时间复杂度和空间复杂度。

例如求累加和的算法，先看依次累加的执行过程：

````java
void addOneByOne() {
    int sum = 0, n = 100;   //执行1次
    for (int i = 0; i <= n; i++) { //执行了n+2次，最后一次判断不再满足要求，跳出
        sum = sum + i;      //执行n+1次
    }
    System.out.println("result is :" + sum); //执行1次
}
````

````c++
void addOneByOne() {
    int sum = 0, n = 100; // 执行1次
    for (int i = 0; i <= n; i++) { // 执行了n+2次，最后一次判断不再满足要求，跳出
        sum = sum + i; // 执行n+1次
    }
    printf("result is: %d", sum); // 执行1次
}
````

`````python
def addOneByOne():
    sum = 0
    n = 100
    for i in range(n + 1):
        sum += i
        if i == n:
            break
    print("result is:", sum)
`````



我们知道，也可以直接使用公式的执行过程：

````java
void addByFormula() {
    int sum = 0, n = 100;   //执行1次
    sum = (1 + n) * n / 2;  //执行1次
    System.out.println("result is :" + sum);//执行1次
}
````

````c++
void addByFormula() {
    int sum = 0, n = 100;  // 执行1次
    sum = (1 + n) * n / 2;  // 执行1次
    printf("result is: %d", sum);  // 执行1次
}
````

`````python
def addByFormula():
    sum = 0
    n = 100
    sum = (1 + n) * n / 2
    print("result is:", sum)
`````

显然第一种执行了1+(n+2)+n+1=2n+4次，而第二种只执行了3次，好坏立见。

我们要记住一句话：==时间复杂度的时间指的是用语句的执行次数，而不是实际的时间。==我们知道计算机执行乘除运算是非常消耗资源的，而加减则计算很快，因此上面的例子不能说两者执行的时间差为2n^2+4n+2，因此时间复杂度只是一个简化的描述。

除了用次数表示时间进行简化，还有一个系数和参数方面的简化。上面的例子中我们找到了非常准确的描述计算次数的方法，但是其实我们更关心当元素数量非常大时的变化情况。

例如y=x+1,当x非常大时，1就可以忽略不计了，我们可以只保留y=x。

而如果y=x\^2+x，当x非常大时，后面的+x作用也不大了，我们可以只保留y=x^2。

同理，y=3x\^2和y=x^2+x+4 ，当x非常大时，此时前面的系数3和4的影响也不大，我们仍然可以只保留y=x^2。

此时我们可以只考虑不同的阶之间的变化情况，如下可以看到过了1之后，不同的表达式的差异将非常巨大。

![image.png](assets/1688657085022-ff8daa85-9ee5-48f5-ac2a-3b91f7dc8e41.png)

所以上面我们可以将表达式分别简化为y=1，y=x和y=x^2，也就是1阶，线性阶和平方阶。

![img](assets/1688657109835-ffc2d8e3-dea6-4242-8d2f-b43d479ded13.png)



### 4.1.2 几种常见的阶

虽然我们不需要证明上面的结论，但是在写算法的时候要能够判断当前代码的阶是多少，特别是 O(logn)，所以我们本节来看一下如何计算阶。

我们要明确一点，时间复杂度针对执行的次数与问题的规模之间的关系来看的。如果只有常数个，不管是10个还是100个，都是常数阶。而如果问题的规模为n，并能够表示规模比较大的情况才会有前面说的近似等价的情况。如果执行次数随着问题规模线性增加就是线性阶，等等。

常见的阶如下：

**(1) 常数阶**

一般顺序执行并且只执行一次的代码就是常数阶，例如上面的sum=（1+n）*n/2。

如果是这样的代码：

````text
sum=sum+1;
sum=sum+2;
sum=sum+3;
sum=sum+4;
````

sum=sum+1;执行了4遍，即使重复了100次，也都是常数级，都用O(1)表示。



**(2)线性阶**

线性阶表示执行的次数随着问题规模是线性变化的，例如下面的格式:

````text
for(int i=0;i<n;i++){
   i++;
}
````

还有while循环:

````text
while(i<n){
   i++;
   //todo
}
````

这里很显然执行todo的次数随着n是线性变化的，因此是线性阶。



**(3)平方阶**

==平方阶主要是双层循环嵌套。==

````tex
int i,j;
for(i=0;i<n;i++){
 for(j=0;j<n;j++){
    //todo 时间复杂度为1的程序
    todo 
 }
}
````

上面的todo随着n是呈平方级别增加的，n是2，就执行4次，n是3就执行9次，所以是平方阶。

这个问题我们还可以改一下，将代码换成这样子：

````text
int i,j;
for(i=0;i<n;i++){
 for(j=i;j<n;j++){
    //todo 时间复杂度为1的程序
    todo 
 }
}
````

此时执行的次数明显只有上面的一半，但是从级别看，仍然是平方阶，只不过执行次数只有一半了，如果感觉不好理解，可以看下面Yovvis同学画的图：

![image.png](assets/1689520571030-ab2055bc-498a-483a-baa0-e10565f4a30b-20231105163215759.png)



**(4) 对数阶**

例如在后面要学习的二分查找，二叉树等问题经常会看到O(logn)。

其本质都可以简化成如下模型:

````text
int count=1;
n=64
int items=0;
while(count<n){
   count=count*2;//todo注意看的是这行的执行次数与n的关系
   itmes++;
} 
````

从上面可以看到，如果todo要执行第七次时，已经不满足count<n了，所以执行次数与n的关系正好是

2^x=n，也就是x=logn。

所以说，二分查找不过是每循环一次都是减半.所以todo的执行次数是logn次。



## 4.2 最坏情况和平均情况

我们查找的时候有n个随机数字，==最好的情况是我们访问的第一个正好就是要找的，最坏的情况是将所有的数据查一遍才找到，不过大部分情况下我们都是在中间某个位置找到。因此这三种情况恰好反应了算法的上下边界和平均状态。==我们后面分析排序等算法时一般都会 考虑某种算法的平均水平怎么样、最坏情况怎么样，而具体如何判断，我们后面具体情况具体分析。



## 4.3 **空间复杂度**

上面谈论的都是时间复杂度，还有一个是空间复杂度。这个非常简单，就看需要申请多少额外的空间来做现在的事情，例如你==需要申请一个或者两三个变量，那么空间复杂度就是O(1)，如果需要申请一个数组，链表、队列、栈或者Hash，其空间复杂度都是O(n)，如果需要申请一个二维数组就是O(n\^2)。==其他的极少用，你申请O(n^2)就已经到面试官能接受的极限了。





# 5.一图看懂算法的体系

很多同学会说算法没有规则，是玄学，只有聪明的人才可以掌握，教官在这里告诉你，不是的，算法是有自己的体系的，循序渐进掌握后，绝大部分问题都是可以搞定的。

那算法的体系到底是什么呢？看下图，我们的目标就是通过这张图带你真正掌握算法：

![算法的体系结构.png](assets/1690299702957-67deee30-1c9e-4865-898a-ce9b77a60eca.png)





















