# 全面理解递归

## 1 什么是递归

### 1.1 递归的定义

==递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。==

简单说程序调用自身的编程技巧叫递归。递归的思想是==**把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止**。==

使用递归需要避免出现死循环，为了确保递归正确工作，递归程序应该包含2个属性：

1. ==基本情况（bottom cases）==，基本情况用于保证程序调用及时返回，不在继续递归，保证了程序可终止。
2. ==递推关系（recurrentce relation）==，可将所有其他情况拆分到基本案例。



### 1.2 总要停下来 - 基本情况

程序中任何操作都不能无穷无尽的执行下去，递归也不例外，所以递归一定要有一个适当的 **“终止条件”**——也就是说，到此为止不会再产生新的调用。

看个例子——假设我们想求一个n的阶乘，也就是`5!=5*4*3*2*1`这种小学都做过的东西

````java
function N(num){
  //5! = 5 * 4!
  return num*N(num-1);
}

N(5);
````

但这个程序不会正确终止，只会报错。为什么？因为这个函数永远会继续往下调用，但我们知道`1!`其实就“到头了”，因为`1!=1`，所以我们完全可以用1作为终止条件

````java
function N(num){
  if(num<=1)return 1;
  else return num*N(num-1);
}

N(5);
````



### 1.3 万物皆可分 - 递推关系

首先，==**绝大多数问题都可以划分成更小的问题**==，通过求解这些小问题，将结果合并在一起得到原本问题的答案，举几个例子：

- 库存清点：大型仓库如果一个人清点可能要好几个月才能完成
  - 解决方案：找20个人各自负责一块，然后把清点**结果汇总**
- 数组求和：假设有有20G的数据需要求和，需要运行很久才能出结果
  - 解决方案：找100台机器一起跑，每个负责200M，然后把各自的**结果相加**
- 搜索引擎：搜索引擎存储了数万亿页面，依靠单台服务器去找需要很久，但根据我们的经验，搜索结果0.x秒就能出来
  - 解决方案：每台服务器负责一部分数据，然后**将各部分搜索结果合并为最终的搜索结果**

从上面几个简单的例子里可以看出，解决大问题时，==**划分为更小的问题分别解决，然后将结果合并起来**==是一种有用的思路。

递归就是对上面思想的应用——把大问题分解为更小的问题，从而便于求解。譬如，`f(n)` 这个范围比较大，我们可以让 `f(n)=n * f(n-1)`。这样，范围就由 `n` 变成了 `n-1` 了，范围变小了，并且为了原函数 f(n) 不变，我们需要让 f(n-1) 乘以 `n`。==说白了，就是要找到原函数的一个等价关系式子，f(n)的等价关系式为 `n * f(n-1)`，即`f(n) = n * f(n-1)`。==



## 2 两种递归模型

### 2.1 模型一：在递去的过程中解决问题

```java
 function recursion(大规模){
   if (end_condition){   // 明确的递归条件
       end;
   }else{
       solve;            // 递去
       recursion(小规模); // 遇到最深处，不断地归来
   }
 }
```

### 2.2 模型二：在归来的过程中解决问题

```java
 function recursion(大规模){
     if (end_condition){  // 明确的递归条件
         end;  
     }else{  // 先把问题全部展开描述，再由尽头“返回”每次解决中剩余的问题
         recursion(小规模);  // 递去
         solve;             // 归来    
     }
 }
 
```



## 3 什么时候使用递归

有以下特征的问题考虑递归求解：

- ==当问题和子问题具有`递推关系`，譬如杨辉三角，计算阶乘。==
- ==具有`递归性质`的数据结构，譬如链表，树，图。==
- ==反向性问题，比如取反。== 

==总结下来，最根本的还是要**抓住问题本身是否可以通过层层拆解到最小粒度来得解。**==



## 4 和循环的关系

是两种不同解决问的思路，递归是很直白地描述一个问题的解题过程，也是我们最容易想到的。循环和递归都有共同的特性，就是重复做任务，有时候使用循环可能不会清晰地描述问题的解决步骤。单从算法设计上看，递归和循环并无优劣之别。然而，在实际开发中，因为函数调用的开销，递归常常会带来性能问题，**特别是在求解规模不确定的情况下；而循环因为没有函数调用开销，所以效率会比递归高。** 递归求解方式和循环求解方式往往可以互换，也就是说，如果用到递归的地方可以很方便使用循环替换，而不影响程序的阅读，那么替换成循环往往是好的。问题的递归实现转换成非递归实现一般需要两步工作：

- 1）自己开辟堆栈（一些局部变量）来保存这些内容便于来替代系统栈，譬如树的三种非遍历方式（后面会讲到）；
- 2） 把对递归的调用转变为对循环处理。特别地，在下文中我们将给出递归算法的一些经典应用案例，对于这些案例的实现，我们一般会给出递归和非递归的解法，方便你体会。



## 5 简单例子

帕斯卡三角形是排列成三角形的一系列数字。也就是有所耳闻的杨辉三角。 在帕斯卡三角形中，**每一行的最左边和最右边的数字总是 1。 对于其余的每个数字都是前一行中直接位于它上面的两个数字之和**。

下面的插图给出了一个 5 行的帕斯卡三角：

![动画展示](assets/1630543201907-1.gif)

这就是个具有具体行数的帕斯卡三角形。

**递推关系**

让我们从帕斯卡三角形内的递推关系开始。

首先，我们定义一个函数 `f(m,q)`，它将会返回帕斯卡三角形第 `m` 行、第 `q` 列的数字。

我们可以使用下面的公式来表示这一递推关系：

```
f(m,q)=f(m−1,q−1)+f(m−1,q)
```

**基本情况**

可以看到，每行的最左边和最右边的数字是基本情况，在这个问题中，它总是等于 1；

因此，我们可以将基本情况定义如下:

```
f(m,q)=1 where q=1 or m=q
```

**演示**

正如我们所看到的，一旦知道了递推关系 和 基本情况，递归函数的实现变得更加直观，特别是在我们用数学表达式表示出这两个元素之后。

下面给出一个例子，展示我们如何用这个公式递归地计算 f(5,3), 也就是 帕斯卡三角形第 `5` 行中的第 `3` 个数。

![动画展示](assets/1630543745338-2.gif)

可以将 f(5,3) 分解为 f(5,3)=f(4,2)+f(4,3)，然后递归地调用f(4,2) 和 f(4,3)：

对于调用的 f(4,2)，我们可以进一步展开它，直到到达基本情况，正如下面描述的： f(4,2)=f(3,1)+f(3,2)=f(3,1)+(f(2,1)+f(2,2))=1+(1+1)=3

对于调用的 f(4,3)，类似地，我们可以将其分解为： f(4,3)=f(3,2)+f(3,3)=(f(2,1)+f(2,2))+f(3,3)=(1+1)+1=3

最后，我们结合上述子问题的结果： `f(5,3)=f(4,2)+f(4,3)=3+3=6`

> 您可能已经注意到递归解决方案可能会导致一些重复的计算，譬如，我们重复计算相同的中间数以获得最后一行中的数字。 假如为了得到 f(5,3) 的结果，我们在 f(4,2) 和 f(4,3)的调用中计算了 f(3,2) 两次，这样重复计算效率肯定不高，下一节我们会给出优化方案来避免重复计算（即记忆术）。



## 6 复杂性分析