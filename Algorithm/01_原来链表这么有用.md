# 1.青铜挑战—小白也能学会的链表（Java/python）

> 链表是一种经典的数据结构，在很多🐂软件里大量使用，例如操作系统、JVM等。
> 在面试中链表题目数量少，类型也相对固定，考察频率却非常高，因此我们只要将常见题目都学完就万事大吉了，所以链表特别值得刷。
>
> 我们将采用两关来征服链表的问题，第一关是链表的基本问题。第二关则是链表反转以及拓展问题。每一关都包含大量的超高频考题，只要过了这两关，我敢保证，以后面试遇到链表，一定不会害怕。
>



## 1.1 单链表的概念 

算法的基础是数据结构，任何数据结构的基础都是创建+增删改查，所有的链表算法题分解到最后，都是这几个操作，所以我们也从这五项开始学习链表。

### 1.1.1 链表的概念 

首先看一下什么是链表？单向链表就像一个铁链一样，元素之间相互连接，包含多个结点，每个结点有且只有一个一个指向后继元素的next指针。表中最后一个元素的next指向null。如下图：

![image.png](assets/1688996783296-c6398d73-228e-4fc6-912a-6a97f832737a.png)

## 1.2 链表的相关概念

**节点和头节点**

在链表中 ，每个点都由值和指向下一个结点的地址组成的独立的单元，称为一个结点，有时也称为节点，含义都是一样的。

对于单链表，如果知道了第一个元素，就可以通过遍历访问整个链表，因此第一个结点最重要，一般称为头结点。

**虚拟结点**

在做题以及在工程里经常会看到虚拟结点的概念，其实就是一个结点dummyNode，其next指针指向head，也就是dummyNode.next=head。

因此，如果我们在算法里使用了虚拟结点，则要注意如果要获得head结点，或者从方法(函数)里返回的时候，则应使用dummyNode.next。

另外注意，dummyNode的val不会被使用，初始化为0或者-1等都是可以的。既然值不会使用，那虚拟结点有啥用呢？简单来说，就是为了方便我们处理首部结点，否则我们需要在代码里单独处理首部结点的问题。在链表反转里，我们会看到该方式可以大大降低解题难度。



## 1.3 **创建链表**

我们继续看如何构造链表。

首先要先理解JVM是怎么构建出链表的，我们知道JVM里有栈区和堆区，栈区主要存引用，也就是一个指向实际对象的地址，而堆区存的才是创建的对象，例如我们定义这样一个类：

````java
public class Course{
    Teacher teacher;
    Student student;
}
````

这里的teacher和student就是指向堆的引用，假如我们这样定义：

````java
public class Course{
    int val;
    Course next;
}
````

这时候next就指向了下一个同为Course类型的对象了，例如：

![image.png](assets/1688480393721-9f4bf1bc-5bff-4b16-884c-8926e1109d45.png)

这里通过栈中的引用（也就是地址）就可以找到val(1)，然后val(1)结点又存了指向val(2)的地址，而val(3)又存了指向val(4)的地址，所以就构造出了一个链条访问结构。
在Java配套代码中BasicLink类，我们debug一下看一下从head开始next会发现是这样的：

![image.png](assets/1688480442862-07b6417f-2fff-4709-85dc-39f8334c7cf0.png)

这就是一个简单的线性访问了，所以链表就是从head开始，逐个开始向后访问，而每次所访问对象的类型都是一样的。
根据面向对象的理论，在Java里规范的链表应该这么定义：

````java
public class ListNode {
    private int data;
    private ListNode next;
    public ListNode(int data) {
        this.data = data;
    }
    public int getData() {
        return data;
    }
    public void setData(int data) {
        this.data = data;
    }
    public ListNode getNext() {
        return next;
    }
    public void setNext(ListNode next) {
        this.next = next;
    }
}
````

但是在LeetCode中算法题中经常使用这样的方式来创建链表：

````java
public class ListNode {
    public int val;
    public ListNode next;

    ListNode(int x) {
        val = x;
        //这个一般作用不大，写了会更加规范
        next = null;
    }
}
ListNode listnode=new ListNode(1);
````

这里的val就是当前结点的值，next指向下一个结点。因为两个变量都是public 的，创建对象后能直接使用`listnode.val` 和 `listnode.next` 来操作，虽然违背了面向对象的设计要求，没有设计 setter 和 getter，但是上面的代码更为精简，因此在算法题目中应用广泛。



## 1.4 链表的增删改查

### 1.4.1 遍历链表

对于单链表，不管进行什么操作，一定是从头开始逐个向后访问，所以操作之后是否还能找到表头非常重要。一定要注意"狗熊掰棒子"问题，也就是只顾当前位置而将标记表头的指针丢掉了。

![image.png](assets/1688480586908-f669aefa-e33f-4bd7-8f09-590ec03f9a78.png)

代码如下：

````java
public static int getListLength(Node head) {
int length = 0;
Node node = head;
while (node != null) {
    length++;
    node = node.next;
}
return length;
}
````



### 1.4.2 链表插入

单链表的插入，和数组的插入一样，过程不复杂，但是在编码时会发现处处是坑。==单链表的插入操作需要要考虑三种情况：首部、中部和尾部。==

**(1) 在链表的表头插入**

链表表头插入新结点非常简单，容易出错的是经常会忘了head需要重新指向表头。 我们创建一个新结点newNode，怎么连接到原来的链表上呢？执行newNode.next=head即可。之后我们要遍历新链表就要从newNode开始一路next向下了是吧，但是我们还是习惯让head来表示，所以让head=newNode就行了，如下图：

![image.png](assets/1688480637126-b708897a-bfce-4879-9b96-ea5ce9a8f94e.png)



**(2) 在链表中间插入**

在中间位置插入，我们必须先遍历找到要插入的位置，然后将当前位置接入到前驱结点和后继结点之间，但是到了该位置之后我们却不能获得前驱结点了，也就无法将结点接入进来了。这就好比一边过河一边拆桥，结果自己也回不去了。
为此，我们要在目标结点的前一个位置停下来，也就是使用cur.next的值而不是cur的值来判断，这是链表最常用的策略。
例如下图中，如果要在7的前面插入，当cur.next=node(7)了就应该停下来，此时cur.val=15。然后需要给newNode前后接两根线，此时只能先让new.next=node(15).next(图中虚线)，然后node(15).next=new，而且顺序还不能错。

**想一下为什么不能颠倒顺序？**

由于每个节点都只有一个next，因此执行了node(15).next=new之后，结点15和7之间的连线就自动断开了，如下图所示：

![image.png](assets/1688480671570-4a23f728-3b49-42a3-b776-eca06c5c6dce.png)



**(3)在单链表的结尾插入结点**

表尾插入就比较容易了，我们只要将尾结点指向新结点就行了。

![image.png](assets/1688480707124-62f77002-1857-42e9-b412-1b0e72318284.png)



综上 ，我们写出链表插入的方法如下所示：

````java
/**
     * 链表插入
     * @param head       链表头节点
     * @param nodeInsert 待插入节点
     * @param position   待插入位置，从1开始
     * @return 插入后得到的链表头节点
     */
public static Node insertNode(Node head, Node nodeInsert, int position) {
    if (head == null) {
        //这里可以认为待插入的结点就是链表的头结点，也可以抛出不能插入的异常
        return nodeInsert;
    }
    //已经存放的元素个数
    int size = getLength(head);
    if (position > size+1  || position < 1) {
        System.out.println("位置参数越界");
        return head;
    }

    //表头插入
    if (position == 1) {
        nodeInsert.next = head;
        // 这里可以直接 return nodeInsert;还可以这么写：
        head = nodeInsert;
        return head;
    }

    Node pNode = head;
    int count = 1;
    //这里position被上面的size被限制住了，不用考虑pNode=null
    while (count < position - 1) {
        pNode = pNode.next;
        count++;
    } 
    nodeInsert.next = pNode.next;
    pNode.next = nodeInsert;

    return head;
}
````

这里需要再补充一点head = null的时候该执行什么操作呢？如果是null的话，你要插入的结点就是链表的头结点，也可以直接抛出不能插入的异常，两种处理都可以，一般来说我们更倾向前者。
如果链表是单调递增的，一般会让你将元素插入到合适的位置，序列仍然保持单调，你可以尝试写一下该如何实现。



### 1.4.3 链表删除

==删除同样分为在删除头部元素，删除中间元素和删除尾部元素。==

**(1)删除表头结点**

删除表头元素还是比较简单的，一般只要执行head=head.next就行了。如下图，将head向前移动一次之后，原来的结点不可达，会被JVM回收掉。

![image.png](assets/1688480747297-f69945b0-d7de-492f-b98f-0fc05fa0aec4.png)



**(2)删除最后一个结点**

删除的过程不算复杂，也是找到要删除的结点的前驱结点，这里同样要在提前一个位置判断，例如下图中删除40，其前驱结点为7。遍历的时候需要判断cur.next是否为40，如果是，则只要执行cur.next=null即可，此时结点40变得不可达，最终会被JVM回收掉。

![image.png](assets/1688480890507-49487e33-103a-425f-a6cc-3aa3b0c7c9fd.png)



**(3)删除中间结点**

删除中间结点时，也会要用cur.next来比较，找到位置后，将cur.next指针的值更新为cur.next.next就可以解决，如下图所示：

![image.png](assets/1688480912895-f80a951d-8d1e-40cd-b4cd-3b857c09e0a1.png)


完整实现：

````java
/**
     * 删除节点
     * @param head     链表头节点
     * @param position 删除节点位置，取值从1开始
     * @return 删除后的链表头节点
     */
public static Node deleteNode(Node head, int position) {
    if (head == null) {
        return null;
    }
    int size = getListLength(head);
    //思考一下，这里为什么是size，而不是size+1
    if (position > size || position <1) {
        System.out.println("输入的参数有误");
        return head;
    }
    if (position == 1) {
        //curNode就是链表的新head
        return head.next;
    } else {
        Node cur = head;
        int count = 1;
        while (count < position - 1) {
            cur = cur.next;
            count++;
        }
        Node curNode = cur.next;
        cur.next = curNode.next;
        //上面两行可以直接简化成：cur.next=cur.next.next
    }
    return head;
}
````

同样，在很多算法中链表元素是有序的，此时如果要删除某个元素，则要先遍历链表，找到目标元素，然后再删除。



### 1.5 课后问题

1.理解Java/Python是如何构造出链表的
2.链表增加元素，首部、中间和尾部分别会有什么问题，该如何处理？
3.链表删除元素，首部、中间和尾部分别会有什么问题，该如何处理？
