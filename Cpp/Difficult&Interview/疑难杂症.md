## C++ 数组

### 为什么指针变量需要类型

指向int的指针的定义是int*，指向结构体Student的指针的定义是struct Student*，虽然都是指针变量，但是即有着不同的类型。

指针变量是用来存储地址的，而地址本质上是一个整数的编号，使用一个能保存整数的变量来存储地址，其实也就可以了。而且C语言中也确实有一个能表示任意类型指针的void*，用于表示和存储任意类型的指针变量。而且无论是什么类型的指针变量，占用的内存空间都是一样的，在32位系统中是4个字节，在64位系统中是8个字节。

更进一步说，在计算机的硬件设计与运行中，也不存在类型的概念，那为什么C语言的指针变量需要类型呢？指针的类型，究竟是定义给谁看的呢？

```c++
#include <stdio.h>
int main()
{
    int a=9888;
    char* p=&a;
    *p=8999;
    printf("a=%d\n",a);
    return 0;
}
```

运行结果：

```ca=9767
a=9767
```

问题出现了，理论上a应该等于8999，怎么会打印9767呢？9767这个结果怎么来的？

我们知道，第一段代码中：int* p = &a；定义指针变量 p 为 int\*型，p 的内存空间里存放 a 的地址，*p指向 int 型的变量 a，而 a 在内存空间中是占4个字节；

代码中：char* p = &a；定义指针变量 p 为 char\*型，p 的内存空间里存放a的地址（注意sizeof（char\*）是4个字节，可以存放 a 的地址），但是\*p指向的却是 int 型变量 a 的低8位，因为 char* p 定义了 *p 只能指向char型的变量，而sizeof（char）是1个字节（8比特位）。

![image-20220813160808937](../../../../../../assets/image-20220813160808937.png)

转化为十进制：9767

这就是打印结果9767的由来。

**总结：总的来说，指针变量及其类型表示了地址的起始位置和长度，决定了如何解释这一块内存，并用于指针的偏移计算，主要的作用是方便开发者和编译器解释和使用内存。可以想像一下，如果没有指针类型，如所有的指针类型都是 char*，则相应的偏移计算和数据解释，都需要开发者来实现，则开发效率和代码可读性必然大大降低。**



## C++ Polymorphism

### C++虚析构函数的必要性

构造函数不能是虚函数，==因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有 意义。==这是原因之一，另外还有一个原因：==C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之 前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不 知道要调用哪一个构造函数。==



